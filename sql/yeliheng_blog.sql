/*
 Source Server Type    : MySQL
 Source Server Version : 5.7
 Source Schema         : yeliheng_blog

 Target Server Type    : MySQL
 Target Server Version : 5.7
 File Encoding         : 65001

 Date: 11/01/2022 17:15:59
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `user_id` bigint(20) NOT NULL COMMENT '创建者用户id',
  `category_id` bigint(20) DEFAULT NULL COMMENT '分类id',
  `title` varchar(255) NOT NULL COMMENT '文章标题',
  `summary` varchar(255) DEFAULT NULL COMMENT '文章梗概',
  `content` mediumtext NOT NULL COMMENT '文章内容',
  `url` varchar(255) NOT NULL COMMENT '持久化URL',
  `visible` tinyint(1) DEFAULT '1' COMMENT '可见性',
  `words` int(11) NOT NULL COMMENT '字数统计',
  `views` int(11) DEFAULT '0' COMMENT '阅读量',
  `reading_time` int(11) NOT NULL DEFAULT '0' COMMENT '阅读需要时间(分钟)',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `url` (`url`) USING BTREE COMMENT '文章持久化Url'
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of article
-- ----------------------------
BEGIN;
INSERT INTO `article` VALUES (2, 1, 5, 'Congratulations! 博客搭建完成', '大功告成', '大功告成\n\n花了我两小时设置了git会用到的SSH key,成功在自己的服务器上部署。中途经历了点小插曲。用Windows下的Powershell push竟然会出现权限问题。\n\n后来换成Git Bash就解决了。\n\n接下来我会不定期分享我的个人经验以及技术文章 请多关照~', 'b87d4a14.html', 0, 90, 379, 1, '2018-11-20 01:14:50', '2018-11-20 01:14:50');
INSERT INTO `article` VALUES (3, 1, 8, '小e开发板(esp8266)连接Arduino实现WiFi扫描', '小e开发板(esp8266)连接Arduino实现WiFi扫描', '这是我很早之前发布在csdn上的一篇原创文章。\n\n链接:[https://blog.csdn.net/yeliheng/article/details/76222734](https://blog.csdn.net/yeliheng/article/details/76222734)\n\n1、首先是接线。\n\n![图1](https://cdn.yeliheng.com/c9d0f09e/1.png)\n\nvcc对应接arduino开发板5V\n\nGND接GND\n\nTXD接TX\n\nRXD接RX\n\nGPI00接GND（这个是上传的时候用，上传的时候必须接地，否则会导致上传失败）\n\n接线是不是很简单？\n\n附上图片一张\n\n![图2](https://cdn.yeliheng.com/c9d0f09e/2.png)\n\n2、接着就是下载Esp8266扩展库了。\n\n打开IDE，点击文件->首选项，如图\n\n![图3](https://cdn.yeliheng.com/c9d0f09e/3.png)\n\n将这串网址填入图上的红圈内:http://espduino.doit.am/package_esp8266com_index.json\n\n重启IDE\n\n点击工具->开发板->开发板管理器\n\n![图4](https://cdn.yeliheng.com/c9d0f09e/4.png)\n\n在搜索框中输入esp8266,点击即可选择对应版本安装。我们选择2.0.0。\n\n注:安装过程漫长，可能需要20分钟，请耐心等待。毕竟是国外的网站。\n\n下载完成后我们就可以把开发板改为Generic Esp8266 Module如图\n\n![图5](https://cdn.yeliheng.com/c9d0f09e/5.png)\n\n3、接着就是上传阶段了。\n\n编译有点慢。\n\n我们点击文件->示例->ESP8266WiFi->WiFiScan，然后点击上传\n\n上传时一定要注意，在arduino显示上传中的时候迅速把小e开发板断电，马上再上电。否则将导致上传失败。\n\n\n\n下图是上传成功的截图:\n\n![图6](https://cdn.yeliheng.com/c9d0f09e/6.png)\n\n这样恭喜你成功啦！\n\n打开串口查看器，会发现小E开发板（esp8266）正在扫描附近WIFI，并显示到串口中，是不是很有成就感？\n\n成品截图:\n\n![图7](https://cdn.yeliheng.com/c9d0f09e/7.png)\n\n附上示例代码:\n\n```java\n/*\n *  This sketch demonstrates how to scan WiFi networks. \n *  The API is almost the same as with the WiFi Shield library, \n *  the most obvious difference being the different file you need to include:\n */\n#include \"ESP8266WiFi.h\"\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Set WiFi to station mode and disconnect from an AP if it was previously connected\n  WiFi.mode(WIFI_STA);\n  WiFi.disconnect();\n  delay(100);\n\n  Serial.println(\"Setup done\");\n}\n\nvoid loop() {\n  Serial.println(\"scan start\");\n\n  // WiFi.scanNetworks will return the number of networks found\n  int n = WiFi.scanNetworks();\n  Serial.println(\"scan done\");\n  if (n == 0)\n    Serial.println(\"no networks found\");\n  else\n  {\n    Serial.print(n);\n    Serial.println(\" networks found\");\n    for (int i = 0; i < n; ++i)\n    {\n      // Print SSID and RSSI for each network found\n      Serial.print(i + 1);\n      Serial.print(\": \");\n      Serial.print(WiFi.SSID(i));\n      Serial.print(\" (\");\n      Serial.print(WiFi.RSSI(i));\n      Serial.print(\")\");\n      Serial.println((WiFi.encryptionType(i) == ENC_TYPE_NONE)?\" \":\"*\");\n      delay(10);\n    }\n  }\n  Serial.println(\"\");\n\n  // Wait a bit before scanning again\n  delay(5000);\n}\n```\n转载请注明出处！', 'c9d0f09e.html', 1, 605, 712, 2, '2018-12-09 00:23:07', '2022-01-01 14:32:56');
INSERT INTO `article` VALUES (4, 1, 5, '为你的网站申请SSL证书并部署HTTPS', '详细的申请SSL证书并部署HTTPS的教程', '# 详细的申请SSL证书并部署HTTPS的教程 #\n\n近期给自己的站点部署了HTTPS协议，趁热打铁把全过程发布到博客供大家学习，交流。转载请注明出处！\n\n在部署之前让我们先粗浅地了解一下HTTPS协议和一些相关概念。\n\n> 1.什么是HTTPS？\n\n\n同样简单地说，就是在HTTP协议的基础上加入SSL层，实现加密传输数据。具体资料请自行使用搜索引擎查找。\n\n> 2.什么是SSL证书？\n\nSSL证书全称：SSL安全通道（Secure socket layer(SSL)。该安全协议主要用来提供对用户和服务器的认证；对传送的数据进行加密和隐藏；确保数据在传送中不被改变，即数据的完整性，现已成为该领域中全球化的标准。\n\nSSL证书是数字证书的一种，**类似于驾驶证、护照和营业执照的电子副本**。因为配置在服务器上，也称为SSL服务器证书。\n\n> 3.什么是CSR？\n\nCSR：全称是证书签发请求(Certificate Signing Request)　即证书请求文件，也就是证书申请者在申请数字证书时由CSP(加密服务提供者)在生成私钥的同时也生成证书请求文件，证书申请者只要把CSR文件提交给证书颁发机构后，证书颁发机构使用其根证书私钥签名就生成了证书公钥文件，也就是颁发给用户的证书。\n\n> 4.什么是CA？\n\nca（certification authority）是以构建在公钥基础设施pki（public key infrastructure）基础之上的产生和确定数字证书的第三方可信机构（trusted third party），其主要进行身份证书的发放，并按设计者制定的策略，管理电子证书的正常使用。\n\n---\n在了解完基本概念之后我们便可以开始**第一步:SSL证书的申请**。\n\n个人认为小站点无需使用付费的ssl证书，所以我们接着就使用一家国内免费的SSL\n\n点击这里去申请免费的SSL:[https://www.pianyissl.com/?i125561](https://www.pianyissl.com/?i125561)\n\n我们进入网址,注册账号之后就能看到首页有免费测试的选项，点击进去。可申请3个月免费时长，并无限续期。\n\n![](https://cdn.yeliheng.com/6726501d/1.png)\n\n接着就是按照提示操作的过程了\n\n![](https://cdn.yeliheng.com/6726501d/2.png)\n\n输入你的域名，这里建议直接使用顶级域名。接着需要进行域名所有权验证。\n\n我建议使用CNAME验证，方便快捷，如图。\n\n![](https://cdn.yeliheng.com/6726501d/3.png)\n\n验证过程可能需要几分钟的时间，可以先喝杯Java。\n\n![](https://cdn.yeliheng.com/6726501d/biaoqing.jpg)\n\n等待验证完成之后就可以去个人中心把证书打包下载到本地啦~\n\n成功了一半，接着我们来将证书安装到服务器上。\n\n这一步，申请证书的官网给出了对应各种WEB服务器的教程，Apache,Nginx,IIS···都不在话下。\n\n这里直接给出网址:[https://www.pianyissl.com/support/lists/3](https://www.pianyissl.com/support/lists/3)\n\n找到对应的服务器点进去即可。\n\n拿nginx为例，在配置文件里找到http{}块，在里面加入\n\n```\n		server {\n		listen 443;\n		server_name localhost;\n		ssl on;\n		ssl_certificate server.crt;\n		ssl_certificate_key server.key;\n		ssl_session_timeout 5m;\n		ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n		ssl_ciphers ECDH:AESGCM:HIGH:!RC4:!DH:!MD5:!aNULL:!eNULL;\n		ssl_prefer_server_ciphers on;\n		location / {\n		root html;\n		index index.html index.htm;\n		}\n		}\n```\n\n**小提示:1.nginx的配置文件，一个http块(即http{})里可以包含多个server{}**\n\n　　　**2.前后的大括号要对应好哦~**\n\n　　　**3.nginx默认配置文件在/usr/local/nginx/conf文件夹里(看你自己有没有修改过喽)**\n\n\n修改完就可以保存退出啦。然后**先别着急重启nginx服务器，先来检查一下配置文件是否正确**\n\n输入:` nginx -t `\n\n如果返回下图结果，则代表配置文件没有任何问题。\n\n![](https://cdn.yeliheng.com/6726501d/4.png)\n\nok，然后你就可以重启nginx啦。\n\n输入:` service nginx restart `\n\n有人可能会问:为什么要先检查再重启？ \n\n如果没有先检查是否有错误就直接重启nginx的话，会导致nginx重启失败，然后在你重新改正配置文件后再重启你会发现nginx已经无法启动了。只能委屈巴巴地reboot\n\n\n已经接近成功啦，让我们把事情做到完美。\n\n现在可能会出现一个问题:当你使用https://访问服务器的时候，可能会出现连接被拒绝的尴尬。怎么办呢？很简单。这是因为服务商防火墙禁用了443端口导致的，而这是我们https必须开放的端口。我使用的是阿里云的服务器，阿里云默认443是禁用的，需要自己登陆后台，将443端口开放，开放后即可正常访问。\n\n最后一步：将http请求自动重定向到https\n\n你会发现，现在你输入https://来访问已经能够访问了，但是倘若你仍然使用http://访问，得到的还是http协议返回的数据，就没有达到加密的目的。怎么让我们访问http://自动跳转到https://呢？\n\n其实炒鸡简单。我们再次打开nginx的配置文件，在里面加入这段:\n\n```\n	server {  #普通的http访问跳转\n        listen       80; \n        server_name  localhost    \n        return       301 https://你的网址;          \n    } \n```\n\n原理就是使用nginx的301跳转，很简单。\n\n同样保存退出，重启nginx。\n\n用浏览器访问，如下图\n\n![](https://cdn.yeliheng.com/6726501d/5.png)\n\n\n\n---\n**到此，我们的https部署全部结束。能够帮到你是我的荣幸。**\n\n**如果你愿意的话就扫描一下赞赏码可以给我打赏，给我鼓励。谢谢**\n\n![赞赏码-微信扫一扫](https://cdn.yeliheng.com/6726501d/zanshang.jpg)', '6726501d.html', 0, 1485, 400, 6, '2018-12-24 18:32:22', '2022-01-04 16:44:30');
INSERT INTO `article` VALUES (5, 1, 6, '我的开源项目-MetalDetector For Android已上线', '基于安卓手机的金属探测仪', '# 下载传送门 #\n\n[酷安](https://www.coolapk.com/apk/217175)\n\n# 软件介绍 #\n\n最近忙着忙着灵感就突然出来了，是否能借助安卓手机内置的传感器来探测金属呢？\n\n后来到Android developer官网上查看了一下手册，发现这个想法是行得通的。\n\n![图1](https://cdn.yeliheng.com/2fffe5d5/1.jpg)\n\nAndroid手机内置磁传感器，可以通过磁传感器计算出磁感应强度，从而在一定程度上实现探测金属。MetalDetector这个软件可以让你的安卓手机变身金属探测器。(仅适用于有一定磁性的金属和支持电子罗盘的安卓手机)\n\n食用方法: 直接将手机靠近金属即可，若识别到金属软件将会震动提示你(可以在设置里关闭震动)，你可以在手机屏幕上看到当前传感器三轴的磁感应强度大小，同时可以看到进度条提示。进度条下方的图表可以更直观地显示出磁感应强度的变化。\n\n![图2](https://cdn.yeliheng.com/2fffe5d5/2.jpg)\n\n重要Tips：**如果你发现传感器不准了，探测不到金属或者一直显示探测到金属，请校准传感器！**\n\n校准方法: **将手机在空中画水平“8”字** 如图所示\n\n![图2](https://cdn.yeliheng.com/2fffe5d5/3.jpg)\n\n如果你对这方面特别感兴趣，想了解内部的实现原理，请前往这个链接:[知乎](https://www.zhihu.com/question/20944506)\n\n# 鼓励我 #\n\n![图2](https://cdn.yeliheng.com/2fffe5d5/zanshang.jpg)\n\n如果你觉得这是沙雕应用，你就截个图到微信扫一扫给我一块钱\n\n如果你觉得本应用很牛逼的话，可以给我更多哦~\n\n开个玩笑，无论多少都感谢鼓励啦~\n\n---\n\n以下是赞赏名单\n\n沦枫--8.89¥\n\n延续--8.88¥\n\n匿名用户--7.00¥\n\n巨龙Jvlong--5.00¥\n\n匿名用户--3.00¥\n\n---\n\n# 软件源代码 #\n\n本软件已在Github开放源代码，可供学习交流使用。\n\n地址: https://github.com/yeliheng/MetalDetector\n\n如果能帮到你就点个Star吧，也是对我的一种鼓励。\n\n# 版权声明 #\n\n本软件遵循[GNU General Public License v3.0](https://github.com/yeliheng/MetalDetector/blob/master/LICENSE)开源许可\n\nYeliheng©版权所有 转载请注明出处！', '2fffe5d5.html', 1, 579, 23038, 2, '2019-01-30 19:53:36', '2022-01-04 16:43:49');
INSERT INTO `article` VALUES (6, 1, 5, '好久不见', '我回来啦', '高考已经结束，时隔133天，回来更新我的小站\n\n我将持续分享我学到的新知识，在与大家分享的同时我能巩固知识，享受分享的快乐！\n\nEnjoy yourself!\n\n让我们共同享受计算机世界的欢乐！', '4ad5100d.html', 1, 70, 236, 1, '2019-06-13 02:58:00', '2019-06-13 02:58:00');
INSERT INTO `article` VALUES (7, 1, 1, '详解Java事件处理机制', '以键盘事件为例详解事件处理', '# 详解Java事件处理机制 #\n\n## 初步介绍 \n\n> Java 事件处理是采取 “委派事件模型”。所谓“委派事件模型”是指当事件发生时，产生事件的对象（即事件源），会把此“信息”传递给 “事件监听者” 处理的一种方式，而这里所说的“信息”实际上就是 \"java.awt.event\" 事件类库里某个类所创建的对象，我们暂时把它称为“事件的对象”\n\n是不是有点抽象,用图来表示就是:\n\n![图1](https://cdn.yeliheng.com/d2adbf0f/1.png)\n\n我们用一个实例来讲解\n\n```java\npackage JavaEventListener;\n\nimport java.awt.Graphics;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class MyEventListener extends JFrame{\n	MyPanel myPanel = null;\n	public MyEventListener() {\n		\n		myPanel = new MyPanel();\n		this.add(myPanel);\n		this.setSize(200,150);\n		this.setVisible(true);\n		this.addKeyListener(myPanel);\n	}\n\n	public static void main(String[] args) {\n	\n		MyEventListener eListener = new MyEventListener();\n	}\n\n}\nclass MyPanel extends JPanel implements KeyListener{\n	int x,y;\n	public void paint(Graphics g) {\n		super.paint(g);\n		g.fillOval(x, y, 20, 20);\n	}\n	@Override\n	public void keyTyped(KeyEvent e) {\n		\n		\n	}\n\n	@Override\n	public void keyPressed(KeyEvent e) {\n		\n		switch(e.getKeyCode()) {\n		case KeyEvent.VK_UP:\n			y--;\n			break;\n		case KeyEvent.VK_DOWN:\n			y++;\n			break;\n		case KeyEvent.VK_LEFT:\n			x--;\n			break;\n		case KeyEvent.VK_RIGHT:\n			x++;\n			break;\n		}\n		this.repaint();\n	}\n\n	@Override\n	public void keyReleased(KeyEvent e) {\n		\n		\n	}\n	\n}\n\n```\n\n这个实例是基于swing的，实例中通过KeyListener来监听键盘事件，从而达到可以使用上下左右键控制小球移动的目的\n\n在这个实例中\n\n事件源是键盘\n\n事件是键盘被按下（释放）\n\n事件监听者是MyPanel对象-->第18行\n\n事件处理方法则是KeyListener中的一系列方法(keyPressed...)-->34行起\n\n这也体现了上面提到的**委派事件模型**\n\n---\n\n## 深入理解\n\n#### ① 事件源\n\n事件源是一个产生或触发事件的对象，如按钮对象，窗口对象等。当这个事件源对象的某些状态以某种方式发生变化时，就会产生某种类型的**事件**(**一个事件源可能会生成多个不同类型的事件**)比如一个窗口可以被最小化，最大化，这就是不同类型的事件。\n\n#### ② 事件\n\n事件就是**承载事件源状态改变时的信息对象**。也可以说事件是事件源向事件监听器传输事件源状态信息的载体。在用户与GUI组件进行交互时就会生成事件，如鼠标移动，窗口大小改变，键盘按下等。在java.awt.event 和javax.swing.event包中定义了各种事件的类型。具体在此不多赘述，请自行查阅jdk文档。\n\n#### ③ 事件监听者\n\n事件监听者实际上是一个类，该类实现了某个事件监听器接口。如上文提到的MyPanel类就作为事件监听者，实现了KeyListener接口，它可以对接收到的事件进行处理\n\n#### ④ 事件监听器接口\n\n事件监听器接口有很多，**不同的事件监听器接口可以监听不同的事件，一个类可以实现一个事件监听接口，也可以实现多个监听接口**就比如上文代码中，我实现了KeyListener，也可以同时实现MouseListener等多个接口。实现后只需要在前面用this.add()注册即可。\n\n## 小结\n\nJava事件监听编写步骤:\n\n1.编写事件处理类\n\n2.给事件处理类实现监听器接口\n\n3.在事件处理类中重写(@Override)其事件处理函数\n\n4.在事件源类中制定该事件的监听器，也就是注册监听(this.add();)\n\n#### 废话时间\n\n为什么要写这篇Blog呢？\n\n这是我高中毕业后写的第一篇文章，顺便重温一下前面Java学习的知识点。\n\n转载请注明出处->Yeliheng的技术小站 谢谢！', 'd2adbf0f.html', 1, 934, 484, 4, '2019-06-16 19:02:00', '2019-06-16 19:02:00');
INSERT INTO `article` VALUES (8, 1, 4, '[踩坑记录]对C编译器SegmentFault 11问题的思考及解决', '做题中踩到的一些坑', '# [踩坑记录]对C编译器SegmentFault 11问题的思考及解决 #\n前几天做到一道Mc插火把的题目(可能有些同学做过),需要开一个二维数组，题目没有给数组的范围，于是我就随意地写了一个5000，没想到问题就这么出现了。\n\n在我使用gcc编译时，编译器并没有抛出异常，但运行的时候异常发生了。\n\n报了一个 **SegmentFault 11** 的错误，并没有指出具体哪行出了错，令人匪夷所思。于是我打开了VScode进行调试。单步调试的过程中我发现当程序执行到main函数中异常被触发，如图所示。\n\n![图1](https://cdn.yeliheng.com/bb4fbbb5/1.png)\n\n从address我判断可能是内存地址分配错误导致的问题。但哪个地方会导致问题的发生呢？\n\n## 问题初步分析 ##\n\n从编译器的角度讲，每定义一个新变量，编译器就会为其开辟一块内存空间，并有内存地址与其对应。所以问题应该就出现在变量的定义了。从我写的代码上看，只有数组需要为其开辟大小，其他均不用。问题很可能就在于我对二维数组的定义上。我尝试着缩小其范围，从5000缩小到2000，问题还是没有得到解决。我又再次将其缩小到1000，问题莫名其妙解决了。\n\n![图2](https://cdn.yeliheng.com/bb4fbbb5/2.png)\n\n---\n\n## 深入分析 ##\n\n程序虽然正常运行，并被评测系统AC，但要问题还是没有真正解决，因为我并不知道其原因所在。Google大法好，我上Google搜寻了一波，终于从本质上弄懂问题。\n\n开始分析:\n\n在弄清楚问题之前需要了解堆栈的概念，相信大家不会陌生，这里引用百度百科上的基本定义\n\n> 栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\n\n对于每个进程或线程来说，栈空间大小是有限的，而局部变量的内存是在栈上分配的，如果局部变量过大，则会出现分配失败的情况，也就是栈溢出。就好比一个桶只能装下5个苹果，在放第六个的时候就掉出来了。\n\n---\n\n## 解决之道 ##\n\n方法应该有很多，我了解到以下两种方法\n\n1.**把数组定义为全局变量**\n\n原因：全局变量分配时，会分配在全局变量空间，不受栈空间大小影响。\n\n2.**手动分配动态内存空间**\n\n通过malloc，calloc, zalloc等函数，可以分配动态内存空间。该空间会分配在堆上，同样不受栈空间的限制。代码会稍复杂。\n\n---\n\nEND 之后就不会再跳进相同的坑里啦', 'bb4fbbb5.html', 1, 846, 297, 3, '2019-07-25 21:21:00', '2019-07-25 21:21:00');
INSERT INTO `article` VALUES (9, 1, 5, '华为正式发布自有操作系统--鸿蒙 OS(开源)', '华为正式发布自有操作系统--鸿蒙 OS(开源)', '--------------------- \n版权声明：本文转载自CSDN资讯\n\n原文链接：https://blog.csdn.net/csdnnews/article/details/98964136\n\n---\n\n中美技术战之下，无数国人在无数个日夜中无不为中华崛起而奋斗，就在今天，我家成果终于初长成！\n\n日前，正在于东莞松山湖总部举办的华为开发者大会上，华为消费者业务 CEO 余承东正式宣布了极具「开天辟地」般意义的鸿蒙 OS 的到来。\n\n# 鸿蒙 OS 共有四大技术特性 #\n\n之所以研发鸿蒙 OS，其实不仅是为了避免关键时期被扼住喉咙的尴尬，对此，余承东也表示，目前 Android/Linux 系统内核代码庞大冗余，难以保证不同终端体验流畅，同时多终端互联网对设备安全也提出了更高的要求，需要软件生态与硬件绑定，降低用户体验与开发效率，因此鸿蒙 OS 应运而生。\n\n![](https://img-blog.csdnimg.cn/20190809173446904.jpg)\n\n虽同是基于微内核，但鸿蒙 OS 与 Google Fuchsia 的微内核有所不同，鸿蒙 OS 是一款基于微内核的全场景分布式 OS，顾名思义，其不仅面向的是智慧大屏、穿戴、车机、音响、手表、手机、PC 等设备的全场景，还有分布式架构支撑，可以提供天生流畅内核级安全生态系统。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWRlci5zaGltby5pbS9mL0NudDhuS25YZG80SVpmU2gucG5n)\n\n细分而言，余承东表示鸿蒙 OS 有以下四大技术优势：\n\n**分布式架构：实现跨终端无缝协同体验**\n\n鸿蒙 OS 的“分布式 OS 架构”和“分布式软总线技术”通过公共通信平台，分布式数据管理，分布式能力调度和虚拟外设四大能力，将相应分布式应用的底层技术实现难度对应用开发者屏蔽，使开发者能够聚焦自身业务逻辑，像开发同一终端一样开发跨终端分布式应用，也使最终消费者享受到强大的跨终端业务协同能力为各使用场景带来的无缝体验。\n\n![](https://img-blog.csdnimg.cn/20190809173528187.jpg)\n\n**天生流畅：确定时延引擎和高性能 IPC 两大技术**\n\n鸿蒙 OS 通过使用确定时延引擎和高性能 IPC 两大技术解决现有系统性能不足的问题。确定时延引擎可在任务执行前分配系统中任务执行优先级及时限进行调度处理，优先级高的任务资源将优先保障调度，应用响应时延降低 25.7%。鸿蒙微内核结构小巧的特性使 IPC（进程间通信）性能大大提高，进程通信效率较现有系统提升 5 倍。\n\n**内核安全：基于微内核架构重塑终端设备可信安全**\n\n鸿蒙 OS 采用全新的微内核设计，拥有更强的安全特性和低时延等特点。微内核设计的基本思想是简化内核功能，在内核之外的用户态尽可能多地实现系统服务，同时加入相互之间的安全保护。微内核只提供最基础的服务，比如多进程调度和多进程通信等。\n\n![](https://img-blog.csdnimg.cn/20190809173652833.jpg)\n\n鸿蒙 OS 将微内核技术应用于可信执行环境（TEE），通过形式化方法，重塑可信安全。形式化方法是利用数学方法，从源头验证系统正确，无漏洞的有效手段。传统验证方法如功能验证，模拟攻击等只能在选择的有限场景进行验证，而形式化方法可通过数据模型验证所有软件运行路径。\n\n**生态共享：统一 IDE 支撑一次开发，多端部署**\n\n鸿蒙 OS 凭借多终端开发 IDE，多语言统一编译，分布式架构 Kit 提供屏幕布局控件以及交互的自动适配，支持控件拖拽，面向预览的可视化编程，从而使开发者可以基于同一工程高效构建多端自动运行 App，实现真正的一次开发，多端部署，在跨设备之间实现共享生态。华为方舟编译器是首个取代 Android 虚拟机模式的静态编译器，可供开发者在开发环境中一次性将高级语言编译为机器码。此外，方舟编译器未来将支持多语言统一编译，可大幅提高开发效率。\n\n# 鸿蒙 OS 的现状 #\n\n在大会上，余承东表示，华为鸿蒙微内核已经投入商用，用于支付、人脸识别、指纹这种高安全级别场景，首次通过了形式化方法的认证，未来华为整个操作系统都将使用鸿蒙。\n\n其实早在 2017 年，鸿蒙内核 1.0 就已完成了技术验证；2018 年，鸿蒙内核 2.0 用于终端 TEE；2019 年，鸿蒙 OS 1.0 将正式落地在智慧屏产品。也就是在明天下午的开发者大会上，华为子品牌荣耀将要发布的新品智慧屏就会首发搭载鸿蒙 OS。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWRlci5zaGltby5pbS9mL045QVRtVmRKd1lzU1JLdzEucG5n)\n\n此外，根据华为发布的鸿蒙 OS 路标显示，预计到 2020 年，鸿蒙 OS 2.0 将落地在创新国产 PC、手表/手环、以及车机等产品中，到了 2021 年，其也会在音箱、耳机等设备上实现同步应用。\n\n当下余承东还宣布，鸿蒙系统将免费开源，并邀请开发者一起来开发这个面向未来的系统。\n\n![](https://img-blog.csdnimg.cn/2019080917093023.jpg)\n\n# 优先支持 Android，鸿蒙 OS 可随时使用！ #\n\n此前，任正非在接受英国媒体采访时曾表示：“鸿蒙系统的产生，本身并不是为了手机用，而是为了做物联网来用的，比如自动驾驶、工业自动化，因为它能够精确控制时延在五毫秒以下，甚至达到毫秒级到亚毫秒级。”\n\n彼时此消息一出，不少开发者稍显失落，并发出“鸿蒙 OS 是否仅为物联网操作系统?”的疑问，而在今天，余承东给了明确的回答，其表示，鸿蒙 OS 可以用在多种设备上，包括手表、手环、车机、PC、平板，当然也可以用在手机上。不过考虑到生态原因，当下还是优先使用 Google Android 操作系统，如果 Android 操作系统无法使用了，大家就随时可以启用鸿蒙 OS。\n\n# 华为方舟编译器 #\n\n“出于 Android，胜于 Android，超越 iOS，并且全面兼容 Android”的华为方舟编译器在诞生之际就带有重大的使命。\n\n![](https://img-blog.csdnimg.cn/20190809173757784.jpg)', 'e57b56ac.html', 0, 1719, 499, 7, '2019-08-11 04:07:00', '2019-08-11 04:07:00');
INSERT INTO `article` VALUES (10, 1, 2, 'VR交互基础学习总结-VR投篮球项目开发', '通过小项目总结Unity VR半个月的学习', '# 背景 #\n\n我从零基础入门Unity VR到现在有半个月的时间，用小项目总结半个月来的学习成果。写这篇blog来与大家分享心得体会。本博文以交互为主，不讨论3D建模的相关知识。\n\n---\n\n# 介绍 #\n\nVR投篮球玩法: 玩家通过按下控制器的Trigger(即扳机)键来拾取篮球，把篮球投入篮框里得分，距离越远分数越高，一局有10次投篮机会。\n\n---\n\n# 项目参数 #\n\n运行设备: HTC VIVE\n\n操作系统: 支持Mac OS 和 Windows\n\n运行环境: SteamVR\n\n开发环境: Unity3D & Visual Studio\n\n配置需求: 见HTC VIVE官网\n\n完整工程代码: [GitHub](https://github.com/yeliheng/BasketballVR)\n\n---\n\n# 项目分析 #\n\n开始项目之前 我们需要准备:\n\n1.篮球3D模型及贴图\n\n2.场地的3D模型\n\n3.SteamVR sdk\n\n4.VRTK包\n\n开发环境就不多赘述了\n\n![图1](https://cdn.yeliheng.com/51969f29/1.png)\n\n![图1](https://cdn.yeliheng.com/51969f29/2.png)\n\n篮球场地的材质贴图就不上了，模拟一下效果即可。\n\n注: 模型资源以及场景贴图来源于Google 侵删~\n\n---\n\n## 开发思路&过程 ##\n\n为了使思路清晰简洁，我把需要实现的功能和需要用到的技术以一一对应的方式呈现。\n\n1.捡球投球 --> 基于控制器的抓取，释放\n\n2.场地的不同方向移动-->基于控制器的传送机制\n(注:防止晕动症的发生这里使用瞬移的方式，游戏中玩家的匀速或非匀速运动都会引起不适)\n\n3.进球计分 --> 碰撞体判断\n\n4.球出界自动返回原点 --> 碰撞体判断\n\n5.计算剩余球数 --> 物体三维坐标跟踪\n\n6.游戏结束的UI交互-->Unity UI交互\n\n---\n\n### 篮球 ###\n\n首先从篮球的特性入手，篮球具有弹性，符合物理规律，所以需要给篮球Rigidbody和Collider组件，让其受地球重力影响，并与地面发生碰撞而不是穿过地面。此时的篮球还未具有弹性，需要我们手动定义。\n\n在project面板中新建一个Physics Material材质，并设置弹力大小以及动摩擦和静摩擦力大小。并将材质赋给篮球模型。此时篮球就可以自由下落和弹起。参数设置如图所示。\n\n![图3](https://cdn.yeliheng.com/51969f29/3.png)\n\n篮球的属性设置完成后我们可以调整篮球在场景中的位置，以便玩家进入游戏时拾取。\n\n### 篮框 ###\n\n当玩家把篮球投进篮框时，篮框需要作出相应的处理:计算得分，并计算剩余球数。\n\n要使篮框作出处理首先需要为篮框添加触发器，当球投入篮框时进行相应处理，否则无动作。具体流程如下:\n\n首先，在篮框内部新建一个空的GameObject,调整GameObject位置及尺寸，使得篮球经过篮框时会与此游戏对象发生碰撞，实现加分处理。\n\n此GameObject无需符合物理规律，不受外力影响。不可被玩家看见，并且篮球与其发生碰撞时可以直接穿过。所以我们为其添加一个BoxCollider,编辑好Collider，使其覆盖物体外围，并在Collider属性中勾选Is Trigger，使其成为一个触发器。\n\n最后，新建一个tag，命名为trigger，并赋给此GameObject。后面写后台交互代码时会用到。\n\n这时，我们的篮框触发器就设置好了。\n\n### UI界面 ###\n\n本项目目的在于总结VR交互技术，所以把UI的权重降低了，但是UI在实际开发中是很重要的。\n\n我们只做一个游戏结束的UI界面和游戏信息显示界面。\n\n首先在Unity的Hierarchy面板中新建一个GameObject 命名为GameOverUI,再把我们的篮球模型复制一个进去，作为UI的子物体，接着创建3D Text 作为子物体，内容为:Game Over。调整UI位置以及大小，注意放在显眼的位置。\n\n然后将做好的GameOverUI拖入Project面板下的Prefab文件夹中，使其成为预制体。然后删除Hierarchy面板中的GameOverUI。这样我们的游戏结束界面就做好了。\n\n同理，我们来制作游戏信息显示界面\n\n在Hierarchy面板右键，选择UI-Canvas新建一个Canvas，重命名为GameInfo\n\n然后在Canvas中新建4个Text，分别用于显示分数文字，分数，剩余球数文字，剩余球数。如图\n\n![图4](https://cdn.yeliheng.com/51969f29/4.png)\n\n### VRTK控制器 ###\n\n导入了VRTK包后需要对控制器进行设置。\n\n我们定义左手控制器用于传送，右手控制器用于投篮。\n\n所以我们为左手控制器添加如下几个组件:\n\n![左手](https://cdn.yeliheng.com/51969f29/left.png)\n\n为右手控制器添加:\n\n![右手](https://cdn.yeliheng.com/51969f29/right.png)\n\n属性参数全部默认即可，需要定制可自行查阅文档定制。这里也不多赘述。\n\n---\n### 后台交互 ###\n\n到此，我们已经准备就绪，可以开始敲后台的交互代码。\n\n完整源码请前往[GitHub](https://github.com/yeliheng/BasketballVR)下载。\n\n\n我第一个实现的功能是球出界自动回到玩家面前。经过考虑为了可玩性就没有设置自动抓取。\n\n代码分析: 要实现这个功能只需要在Update函数中不停判断球和玩家摄影机的位置即可。同时有个问题需要注意。如果单把球移到玩家面前我们会发现球还在不停弹跳。由于球具有一定的初速度，且符合物理规律，所以这个现象是正常的。我们要解决它，就将球移动时的初速度设为0，即所谓的“瞬移”。\n\n代码片段如下:\n\n```csharp\n        if(transform.position.y <= -1)\n        {\n            //isForceNeed = true;\n            Debug.Log(\"球出界了\");\n            //Destroy(gameObject);\n            rb = GetComponent<Rigidbody>();\n\n            //给刚体设置一个速度 确保物体落地后不再受弹力影响\n            rb.velocity = new Vector3(0, 0, 0);\n            pos = Camera.main.transform.position;\n            pos.y = 0;\n\n            //将物体移动到摄影机下方，方便抓取\n            transform.position = pos;\n            rb.velocity = new Vector3(0, 0, 0);\n        }        \n```\n       \n接着需要实现进球加分功能。这个功能很简单，直接判断篮球是否碰撞触发器即可。（这里存在一个bug，当球自下而上抛时也会加分，这个后期可以通过空间向量解决）\n\n写一个OnTriggerEnter()函数，在里面进行相关处理:\n\n```csharp\n   //触发器被触发\n    private void OnTriggerEnter(Collider other)\n    {\n        Debug.Log(\"OnTriggerEnter触发！Tag是\" + other.tag);\n        if (other.CompareTag(\"trigger\") && !isGameOver)\n        {\n            //Debug.Log(\"球进了！\");\n            //距离计算\n            Debug.Log(distanceCal(other));\n            //总分统计 总分=基础分+距离四舍五入分\n            scoreCount += basicScore + (int)Math.Round(distanceCal(other), 0);\n            //刷新显示\n            score.text = scoreCount.ToString();\n        }\n\n        if (isGameOver)\n        {\n            RestartGame();\n        }\n        \n    }\n```\n\n这里我们的分数不是简单的+1操作。\n\n进球的得分=基础分+距离分\n\n所以我们需要判断玩家投球的位置离篮框有多远。思路是计算两个空间向量之间的距离。我们可以使用距离公式来实现，也可以更简单地调用Vector3类中的distance()函数来计算出距离，效率上差别不大。\n\n我自己封装了一个距离计算函数，代码如下:\n\n```csharp\n//计算出玩家与碰撞体之间的距离，用于统计分数\n    private float distanceCal(Collider other)\n    {\n        Vector3 v_player = Camera.main.transform.position;\n        Vector3 v_collider = other.transform.position;\n        float distance = Vector3.Distance(v_player, v_collider);\n        return distance;\n    }\n```\n\n这样，在进球时的得分就会根据距离改变，距离越远，分数越高。\n\n接着我们需要来判断什么时候从剩余球数里面减一。\n\n我最初的思路是判断控制器扳机放开的瞬间，把球数减一。但考虑到玩家可能手滑或者需要运球，这样就会导致剩余球数频繁减少，直接Game over。\n\n所以我决定换一个思路。当球达到一定高度时剩余球数才会减少。这样可以防止手滑或者运球造成的“冤枉”。\n\n这个地方有一个注意点：球本身是有弹性的，如果不加判断的话，落地后重新弹起也会造成剩余球数减少，球高抛在空中停留也会造成次数多次减少。所以我们只将第一次达到那个高度时的球称为有效，其他均无效。这就需要引入一个开关变量，作为标志。\n\n定义一个bool变量，命名为ballCircle\n\n当达到一定高度时，ballCircle为真，直到球贴地并且末速度接近0时ballCircle才设为假，重新开始下一球的判断。\n\n此部分代码如下:\n\n```csharp\n        rb = GetComponent<Rigidbody>();\n        if(transform.position.y >= 2.5f && !ballCircle)\n        {\n            totalBall--;\n            ball.text = totalBall.ToString();\n            ballCircle = true;\n        }\n        //Debug.Log(\"速度: x: \" + rb.velocity.x + \" y: \" + rb.velocity.y + \" z: \" + rb.velocity.z);\n        if (rb.velocity.y > -1.0f && rb.velocity.y < 1.0f && transform.position.y < 2f)\n        {\n            ballCircle = false;\n        }\n```\n\n到此，我们的评分和计算剩余球数的功能全部完成。\n\n最后是游戏结束界面的显示以及玩家和界面的交互。\n\n我们前面已经将游戏结束的UI制作成prefab，到了调用它的时候了。\n\n我们定义一个函数名称为:onGameOver(),在剩余球数为0的时候延时3秒调用它。在函数中，我们需要实例化我们制作的prefab，将它显示出来。代码如下:\n\n```csharp\n private void onGameOver()\n    {\n        isGameOver = true;\n        Debug.Log(\"游戏结束\");\n        //生成游戏结束UI\n        restartUI = Instantiate(GameOverUI);\n        rb = restartUI.GetComponent<Rigidbody>();\n        rb.angularVelocity = new Vector3(0, 2, 0);//让UI旋转，提升体验\n        restartUI.transform.position = new Vector3(-4, 4, 3);\n       \n    }\n```\n\n玩家要重新开始游戏怎么办？\n\n有很多种方法，我想到用控制器去触碰游戏结束界面来重新开始游戏，但后来想想，觉得很麻烦，玩家需要先传送到UI前面才能触碰到。后来就采用简单粗暴的方法，当玩家重新拾取篮球时直接开始新的一局，重置分数和剩余球数。即简单又方便。代码如下:\n\n```csharp\nif (isGameOver)\n        {\n            RestartGame();\n        }\n```\n\n```csharp\n//重新开始游戏\n    public void RestartGame()\n    {\n        Debug.Log(\"游戏将在1秒后重新开始...\");\n        Destroy(restartUI);\n        //延时调用初始化函数\n        Invoke(\"init\", 1);\n    }\n```\n\n思路其实很简单，同样是用一个bool变量来存储游戏是否结束的状态，然后进行相关处理。\n\n整个项目的开发思路基本就是这样的，通过这样一个小项目的开发，可以巩固VR交互的知识，在开发中会有一些坑的出现，解决掉下次就不会再次跳坑里了。\n\n最后就是打包发布了。这部分同样不是我们的重点，这里也不详细说明了。\n\n---\n\n# 总结 #\n\n我写这个小项目的灵感来源于对计算机的热爱以及对新知识的追求。看起来很小的一个项目实际上涵盖了VR交互的基础知识点，包括unity3d的基本操作、SteamVR以及VRTK sdk的使用、VR控制器的交互:抓取物体、传送、控制器事件、C Sharp编程等内容。可以很好地总结这阶段的学习，并在实践中获取新知。\n\n完整的工程文件可在[GitHub](https://github.com/yeliheng/BasketballVR)上下载，以及成品都会发布在GitHub。欢迎大家指出问题。', '51969f29.html', 1, 2852, 719, 11, '2019-09-03 05:57:00', '2022-01-11 12:02:51');
INSERT INTO `article` VALUES (11, 1, 3, '[内网穿透] 使用Frp在Linux上实现内网穿透', '[内网穿透] 使用Frp在Linux上实现内网穿透', '## 介绍 ##\n\n近期在开发的过程中有一台服务器还没来得及托管到数据中心，暂时放在工作室，但工作室没有公网IP，正好我有一台闲置的云服务器，故使用frp进行内网穿透，以便外网能够连接ssh以及实现网页的访问。\n\nFrp 是一款开源的软件，能够轻松实现内网穿透，方便服务器上架前远程的调试。\n\n本文重点在于搭建frp内网穿透服务器，具体内网穿透原理在这里不多赘述，大家自行查阅资料。\n\n## 使用前准备 ##\n\n**1.一台处于内网的主机**\n\n**2.一台公网Linux服务器**\n\n**3.Frp**\n\n## 详细步骤 ##\n\nFrp的配置包含客户端和服务端\n\n### 服务端 (有公网ip的服务器)###\n\n**1.从GitHub上下载Frp**\n\n` wget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz `\n\n**2.解压Frp**\n\n` tar -zxvf frp_0.13.0_linux_amd64.tar.gz `\n\n**3.切换到Frp所在目录**\n\n` cd frp_0.13.0_linux_amd64 `\n\n**4.观察目录结构**\n\n`ls`\n\n![图1](https://cdn.yeliheng.com/f8c5ab4c/1.png\n)\n\n从目录结构我们可以看出 目录中包含了几个ini文件，其中我们要用到的是客户端的ini文件，顾名思义就是frps.ini,c即server。\n\n**5.编辑配置文件**\n\n```\n[common]\nbind_port = 7000\nvhost_http_port = 2333\n\n```\n\nbind_port就是客户端与服务器通讯的端口，随便定义一个自己喜欢的端口，一定要开放的，空闲的。默认是7000。\nvhost_http_port就是与自己内网服务器http请求连接的端口。\n\n**6.运行frp服务端**\n\n这一步会在下文客户端配置完成时细讲。\n\n### 客户端 (没有公网的服务器)###\n\n**1.从GitHub上下载Frp**\n\n`wget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz `\n\n**2.解压Frp**\n\n` tar -zxvf frp_0.13.0_linux_amd64.tar.gz `\n\n**3.切换到Frp所在目录**\n\n` cd frp_0.13.0_linux_amd64 `\n\n**4.观察目录结构**\n\n`ls`\n\n从目录结构我们可以看出 目录中包含了几个ini文件，其中我们要用到的是客户端的ini文件，顾名思义就是frpc.ini,c即client。\n下面让我们编辑它\n\n**5.编辑配置文件**\n\n配置文件如下:\n\n```\n[common]\nserver_addr = xx.xx.xx.xx\nserver_port = 7000\n\n```\n\n7000端口是frp客户端与服务端通讯的端口，必须与服务端上的端口相同，这是后面所有通讯的基础，所以必须配置正确。\n\n接下来，我们来配置web访问。刚才我们已经在远程服务器上开放了2333端口，用于web的访问。现在我们对客户端进行配置。\n\n客户端配置如下:(直接继续往下写)\n```\n[web]\ntype = http\nlocal_port = 80\ncustom_domains = www.yeliheng.com\n```\n\ntype字段我们设置为http协议，local_port就是本地端口的意思，我这边本地是80端口。如果我们需要通过域名进行访问我们就绑定域名，将custom_domains填入，这边我的域名是www.yeliheng.com\n\n到此，我们客户端与服务端的配置文件全部编辑完成。只差一步即可完成内网穿透。\n\n**6.运行frp**\n\nfrp有几个参数，这边我们用到的只是-c参数。具体的参数可前往GitHub查看详细手册。\n\n首先，我们需要先把服务端跑起来，先运行服务端的原因在于服务端运行后会等待客户端连接，防止客户端连接服务器失败自动退出。\n\ncd到frp的安装目录下，然后执行如下指令:\n\n` ./frps -c frps.ini &`\n\n运行后一般不会返回任何提示，具体的信息请直接查看日志。(frps.log)\n\n在末尾加一个&表示后台运行。\n\n接下来启动frp客户端\n\n在客户端输入:\n\n` ./frpc -c frpc.ini & `\n\n这时 客户端与服务端将建立连接，内网穿透全部完成。\n\n我们现在可以通过外网访问内网资源了。\n\n浏览器输入**域名:2333**即可访问刚才配置的web\n\n## Tips ##\n\n若要实现frp稳定处于后台运行并且跟随服务器开机自启，有多种解决方案。经过测试，我极力推荐使用pm2作为解决方案。十分稳定并且相当于守护进程，进程崩溃则自动重启进程。pm2的用法请见我的下一篇blog。', 'f8c5ab4c.html', 1, 1117, 335, 4, '2019-09-25 18:49:00', '2019-09-25 18:49:00');
INSERT INTO `article` VALUES (12, 1, 3, 'Linux下实现软件稳定后台运行以及开机自启解决方案-PM2', '使用PM2保持应用稳定处于后台运行状态', '# 背景 #\n\n使用Linux系统我们常会遇到需要软件在后台运行，并且开机自启的情况。要实现后台运行以及开启自启有许多种解决方案，比如screen,&即可实现后台运行，将服务加入rc.local中可以实现开机自启。但经过研究，我推荐一种Linux下绝佳的后台运行以及开机自启的解决方案，优点是极其稳定，并且使用方便。缺点我暂时想不到2333\n\n# 开始 #\n\n## PM2介绍 ##\n\n### 官方简介 ###\n\n> PM2 is a daemon process manager that will help you manage and keep your application online. Getting started with PM2 is straightforward, it is offered as a simple and intuitive CLI, installable via NPM.\n\n### 我写的简介 ###\n\n**PM2是一款基于node开发的软件，用于实现对进程的守护，也就是当用户断开连接时，我们的进程/服务能够继续保持稳定地后台运行,并且通过一个指令即可实现开机自启。**\n\n## Node.js&npm的安装 ##\n\n由于PM2是基于node开发的软件，所以我们必须先搭建node\n\n这里以Ubuntu发行版为例:\n\n将PPA加入到我们的系统中\n\n```\n$ sudo apt-get install curl\n$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -\n\n```\n\n然后直接运行apt安装\n\n`$ sudo apt-get install nodejs`\n\n验证是否安装成功\n\n\n`$ node -v`\n\nv12.10.0\n\n`$ npm -v`\n\n6.10.3\n\n若执行命令后返回以上信息即安装成功\n\n## PM2的安装 ##\n\n在安装完NPM环境后我们开始安装pm2。PM2的安装非常简单，只需要一句话即可完成。\n\n`npm install pm2@latest -g`\n\n等待安装完成后我们即可进行pm2的相关配置了\n\n## PM2的配置 ##\n\n我们需要新建一个文件用于启动服务，然后将这个文件添加如PM2，让PM2守护它，从而间接达到让我们的服务稳定后台运行的目的。\n\n在你喜欢的目录下新建一个app.js文件，然后我们开始写。\n\n这里以我上一篇文章为例，我们将内网穿透的frp软件加入到js文件中，然后让pm2守护它。\n\n这边我们是以js为例，使用其他脚本(如:.sh , .out, .py, .class)也完全没问题。\n\n```\n//固定格式\n\nvar cp=require(\"child_process\");\n\n//下面这句话需要修改哦\n\ncp.spawn(\"/home/frp/frps\",[\"-c\",\"/home/frp/frps.ini\"]).stdout.pipe(process.stdout);\n\n/*\n解释: 小括号里面直接写上软件安装的路径即可,中括号里面填入我们需要的参数（注意：不需要空格）。只需要修改这两个地方即可，其他地方直接复制粘贴。\n\n这句代码等价于如下Linux指令: \n\n$ ./home/frp/frps -c /home/frp/frps.ini\n\n*/\n\n```\n\n这里提醒一下: 在pm2中路径一定要使用绝对路径，否则会造成代码中的路径与你运行指令的路径有关，导致\"No such file or dictionary\"。\n\n\n配置完成后，我们即可运行我们的守护进程。\n\n直接输入:\n\n`$ pm2 start app.js`\n\napp.js是我们刚刚新建的文件。\n\n\n到此，我们的应用已经能够实现稳定地后台运行。接下来，我们要实现应用的开机自启。\n\n## PM2的开机自启 ##\n\n很简单，命令如下:\n\n```\n$ pm2 startup\n\n$ pm2 save\n\n```\n\n大功告成，接下去，需要后台运行以及开启自启的应用全部可以扔到app.js中运行，一劳永逸。\n\nEND', 'b481fec5.html', 1, 855, 408, 3, '2019-09-25 18:49:00', '2019-09-25 18:49:00');
INSERT INTO `article` VALUES (13, 1, 5, '12月北京区块链培训总结', '对12月份北京区块链培训总结', '# 前言 #\n\n上周，我们团队组织前往北京进行为期一周的区块链培训，写一篇来总结这次培训，白嫖许多知识/滑稽，也算不虚此行。\n\n这里感谢[布比区块链](https://bubi.cn/)公司对我们团队提供的支持！\n\n---\n\n# 区块链总结 #\n\n## 概念 ##\n\n首先从区块链的概念开始，什么是区块链。简单笼统地说，**一种多方共同维护同一份“账本”的技术就是区块链**。当然，此处不止局限于账本，账本仅作为举例。\n\n## 特点 ##\n\n区块链的特点: **不可伪造、全程留痕、可以追溯、公开透明、集体维护**等\n\n区块链之所以具有这些特点，具体就要追溯到数学算法和密码学上。\n\n## 共识算法 ##\n\n区块链拥有多种共识算法，用于验证该笔交易是否有效。\n\n>注:这里的交易不止是金融上交易的概念，在区块链中，每次的上链统称交易(transaction)\n\n共识算法有很多种，各有优劣。了解共识算法之前需要先了解拜占庭将军问题。\n这里采用百度百科的概念简单介绍:\n\n### 拜占庭将军问题 ###\n\n拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了达到防御目的，每个军队都分隔很远，将军与将军之间只能靠信差传消息。 在战争的时候，拜占庭军队内所有将军和副官必须达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又扰乱整体军队的秩序。在进行共识时，结果并不代表大多数人的意见。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题就此形成。\n\n拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。\n\n###  实用拜占庭容错算法(PBFT)  ###\n\n在实际开发中，我们采用的是实用拜占庭容错算法，改进型实用拜占庭容错的共识机制是少数服从多数，根据信息在分布式网络中节点间互相交换后各节点列出所有得到的信息，一个节点代表一票，选择大多数的结果作为解决办法。PBET将容错量控制在全部节点数的1/3，即如只要有超过2/3的正常节点，整个系统便可正常运作。\n\n---\n\n包括PBFT在内，还有许多种共识算法，这里通过一张图介绍，概括优劣。\n\n![](http://cdn.yeliheng.com/WX20200211-215737%402x.png)\n\n其中，POW工作量证明就是我们常说的“挖矿”。\n\n## 加密方式 ##\n\n简单介绍完几种常见的共识算法，接下来关注密码学上常见的两种加密方式。如图所示:\n\n\n![](http://cdn.yeliheng.com/WX20200211-220213%402x.png)\n\n流程清晰明了。\n\n## 交易流程 ##\n\n区块链中的交易主要分为以下两种模型: UTXO模型的账本、Account模型的账本。\n\n### UTXO模型的账本 ###\n\nUTXO即未花费交易输出，通俗的讲，相当于你把100元存入某个地方，呃，就叫银行吧，然后银行在存储这笔钱时，将其分为10元、20元、20元、50元进行存储，也可以理解为现实中的找零。。较为抽象\n\n**优点**：\n\n计算是在链外的，交易本身既是结果也是证明。节点只做验证即可，不需要对交易进行额外的计算，也没有额外的状态存储。交易本身的输出 UTXO 的计算是在钱包完成的，这样交易的计算负担完全由钱包来承担，一定程度上减少了链的负担。\n\n交易的 Input 始终是链接在某个 UTXO 后面。交易无法被重放，并且交易的先后顺序和依赖关系容易被验证，交易是否被消费也容易被举证。\n\nUTXO 模型是无状态的，更容易并发处理。\n\n安全性比Account高\n\n**缺点**：\n\n无法实现一些比较复杂的逻辑，可编程性差。对于复杂逻辑，或者需要状态保存的合约，实现难度大，且状态空间利用率比较低。\n\n当 Input 较多时，见证脚本也会增多。而签名本身是比较消耗 CPU 和存储空间的。\n\n![](http://cdn.yeliheng.com/WX20200211-221743%402x.png)\n\n### Account模型的账本 ###\n\n\n顾名思义,Account模型即账户模型，也就是每笔交易都有对应的账户，围绕账户进行。Account模型保存了交易的事件状态，交易只是事件本身，不包含结果，交易的共识和状态的共识本质上可以隔离的。\n\n**优点**：\n\n合约以代码形式保存在 Account 中，并且 Account 拥有自身状态。这种模型具有更好的可编程性，容易使开发人员理解，场景更广泛。\n\n批量交易的成本较低。\n\n**缺点**：\n\nAccount 模型交易之间没有依赖性，需要解决重放问题。\n\n对于实现闪电网络/雷电网络，Plasma 等，用户举证需要更复杂的 Proof 证明机制，子链向主链进行状态迁移需要更复杂的协议。\n\n工作原理如图所示\n\n![](http://cdn.yeliheng.com/WX20200211-222040%402x.png)\n\n---\n\n## 上链流程 ##\n\n上链是交易的关键一步，直接关系到此次交易是否成功，流程如下图所示。\n\n![](http://cdn.yeliheng.com/WX20200211-222231%402x.png)\n\n最后，我以以太坊为平台，成功发布了自己的智能合约(YlhCoin)，具体发布流程请自行查阅手册。\n\n代码如下:\n\nylhCoin.sol\n\n```js\npragma solidity ^0.5.14;\ncontract MyCoin{\n	address public god;\n	uint256 public total;\n	mapping(address => uint256) public balances;\n	\n	constructor() public{\n		god = msg.sender;\n		total = 10000000;\n		balances[god] = total;\n	}\n	//获取余额\n	function getBal(address owner) public view returns(uint256){\n		return balances[owner];\n	}\n	//转账\n	function transaction(address payee,uint256 amount) public returns(bool){\n		address owner = msg.sender;\n		require(amount > 0);\n		require(balances[owner] >= amount);\n		balances[owner] -= amount;\n		balances[payee] += amount;\n		return true;\n	}\n}\n\n```\n\nylhCoin_OpenSource.js\n\n```javascript\n\nlet fs = require(\'fs\');\nlet Web3 = require(\'web3\');\nlet privateKey = Buffer.from(\"你的私钥\",\"hex\");\nlet Tx = require(\'ethereumjs-tx\').Transaction;\n//打开服务器\nlet provider = new Web3.providers.HttpProvider(\"https://ropsten.infura.io/v3/8a4622e55aa842d99e232dafdece2605\");\nlet web3 = new Web3(provider);\n//console.log(web3);\n\n//读取ABI和BIN\nylhCoinABIObj = fs.readFileSync(\'ylhCoin_sol_MyCoin.abi\');\nylhCoinABIJson = JSON.parse(ylhCoinABIObj.toString());\n//console.log(\"ABI:\" + ylhCoinABIObj.toString());\nconsole.log(\"-------------------------\");\nylhCoinBinObj = fs.readFileSync(\'ylhCoin_sol_MyCoin.bin\');\nylhCoinByte = ylhCoinBinObj.toString();\n//console.log(\"BIN:\" + ylhCoinByte);\nconsole.log(\"-------------------------\");\n\n//部署合约\naccount = {\naddress: \"钱包地址\",\nprivateKey: \"你的私钥\"\n}\n//console.log(\"当前账户: \" + account);\ncontract = new web3.eth.Contract(ylhCoinABIJson);\n//contract = new web3.eth.Contract(ylhCoinABIJson);//合约核心文件(ylhCoinABIJson)\n//console.log(contract);\n\n(async()=>{\nlet nowNonce = await web3.eth.getTransactionCount(account.address);\nconsole.log(\"Nonce: \" + nowNonce);\n//构建交易(合约数据)\ntxData = {\n	nonce: nowNonce,\n	data:  \"0x\" + ylhCoinByte,\n	from: account.address,\n	gasPrice: \'0x01\',\n	gasLimit: \'0xfffff\',\n	value: web3.utils.toHex(web3.utils.toWei(\"1\",\"ether\")),\n	to: \'收款人的钱包地址\'\n}\n//签发交易(使用私钥)\nlet tx = new Tx(txData,{\n	chain: \"ropsten\",\n	//hardfork: \"petersburg\"\n});\ntx.sign(Buffer.from(privateKey,\"hex\"));\nlet serializedTx = tx.serialize();\n//sendSignedTransaction\n//签发!\nweb3.eth.sendSignedTransaction(\'0x\' + serializedTx.toString(\'hex\')).on(\'receipt\',console.log);\n})();\n\n```\n\n最终运行效果如图:\n\n![](http://cdn.yeliheng.com/46405AD0-E478-42EE-9C4B-AB45F016FBB1_1_105_c.jpeg)\n\n代码地址:[Yeliheng-Github](https://github.com/yeliheng/YlhCoin)\n\n完结撒花', '497f1caf.html', 1, 2011, 322, 8, '2019-12-21 05:04:00', '2019-12-21 05:04:00');
INSERT INTO `article` VALUES (14, 1, 5, '武汉加油,中国加油!', '武汉加油，中国加油!!!2020一定会好起来！', '让我们一起为武汉加油！一起打赢这场防疫战！防控疫情，从你我做起！愿大家健康、平安！向疫情前线的医护人员们致敬，辛苦了！\n　　\n　　武汉加油！此时此刻，心系武汉，共战疫情，万众一心！\n　　\n　　风华模样，你落落大方；家国有难，你迎难而上。这些前线姑娘，斗志昂扬，不再是一个人，拼搏在战场上。前线姑娘，勇敢善良，全国人在期盼，胜利后回家乡 …..\n　　\n　　武汉加油！樱花烂漫时，再来相会！\n　　\n　　天佑中国，自强不息，必胜疫情！\n　　\n　　感谢奋战在疫区一线的医务人员，人民警察，防疫人员，人民子弟兵，夜以继日工作的火神山医院工程建设者，放弃休假连续加班的口罩厂员工！ 我们在过年，这群人在帮我们过关。隔离病毒，绝不是隔离爱。14亿人万众一心、众志成城，就没有我们过不去的坎！武汉加油！中国加油！\n　　\n　　致敬所有奋战在一线的医务工作者和科研人员，保护好自己和他人\n　　\n　　武汉加油！中国加油！我们一定可以打赢这场仗！！！\n　　\n　　疫情关上了家门，就让音乐打开心门。出门戴口罩，回家勤洗手一起为武汉加油\n　　\n　　感谢所有“坚守”，致敬所有“逆行”！疫情面前，我们呼吁大家佩戴口罩、勤洗手、少出门、避免聚会。重视防护，共克时艰！武汉加油！中国加油！\n　　\n　　让祝福化作春风，请你多保重。同胞心相连，逆行中的吧白衣天使。啊，让中国感动、感动\n　　\n　　战斗正在进行，生活仍在继续 武汉加油，中国加油！ 抗过洪水，踏过冰灾！ 相信这次也一定能取得胜利\n　　\n　　再艰难，爱不会离开！此刻我们都是武汉人！万众一心，众志成城，就没有中国人民跨不过去的坎！武汉加油！中国加油！\n　　\n　　全国人民加油!我们这个民族!之所以能延续5000年的历史!是因为这个世界上!从没有任何困难可以难住我们的中华民族!\n　　\n　　火神山、雷神山、钟南山， 三山齐聚克难关； 国内捐、海外捐、李兰娟， 众捐纷来达通途； 男护士、女护士、前线人士， 中国勇士齐抗疫； 医者心、仁者心、中国心， 万众一心不畏难！', 'fb2298c9.html', 0, 632, 245, 3, '2019-12-21 05:04:00', '2019-12-21 05:04:00');
INSERT INTO `article` VALUES (15, 1, 6, 'Android RecyclerView的基础实现', '安卓实现RecyclerView全过程', '自从Google更新AndroidX后，之前所有的android.support库都迁移到android.x上了。\n\n现在项目也不再使用古老的Andorid support库了，查阅文档，了解到原com.android.support:recyclerview-v7已经迁移到androidx.recyclerview:recyclerview，直接上rc稳定版，即androidx.recyclerview:recyclerview:1.1.0-rc01\n\n在Gradle闭包中加入:\n\n```gradle\ndependencies {\n	...\n    implementation \"androidx.recyclerview:recyclerview:1.1.0-rc01\"\n    ...\n}\n\n```\n\n接着在activity_main中加入recyclerview:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_height=\"match_parent\"\n    android:layout_width=\"match_parent\">\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recycler_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"/>\n</LinearLayout>\n```\n\n然后新建一个ListObject类，方便我们后面向链表中加入item\n\n```java\n\npackage com.droidye.droidreview;\n\npublic class ListObject {\n\n    private String name;\n\n    public ListObject(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n}\n\n```\n\n为item定制样式:新建一个list_item.xml\n\n```xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n<TextView\n    android:id=\"@+id/name\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"60dp\"\n    android:layout_gravity=\"center_vertical\"\n    android:layout_marginLeft=\"10dp\"\n    android:textSize=\"30sp\"\n    />\n</LinearLayout>\n\n```\n---\n\n准备工作完成，要开始写适配器了。\n\nRecyclerView要正常运行需要以下几个条件:\n\n1.必须指定一个适配器Adapter\n\n2.必须指定一个布局管理器LayoutManager\n\n---\n创建适配器的一般流程:\n\n① 创建Adapter：创建一个继承RecyclerView.Adapter<VH>的Adapter类（VH是ViewHolder的类名）\n  \n② 创建ViewHolder：在Adapter中创建一个继承RecyclerView.ViewHolder的静态内部类，记为VH。\n\n③ 在Adapter中实现3个方法：\n\n● onCreateViewHolder()\n\n这个方法主要生成为每个Item inflater出一个View，返回值是一个ViewHolder。View会被封装在ViewHolder中。\n\n● onBindViewHolder()\n\n可以理解为将数据渲染到适配器中，在这个方法内进行setText等相关操作，点击事件也在此方法内完成。\n\n● getItemCount()\n\n顾名思义，统计item的数目\n\n适配器完整代码实现如下:\n\n```java\n\npackage com.droidye.droidreview;\n\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport androidx.annotation.NonNull;\nimport androidx.recyclerview.widget.RecyclerView;\nimport java.util.List;\n\npublic class ListAdapter extends RecyclerView.Adapter<ListAdapter.ViewHolder> {\n    private List<ListObject> mList;\n\n    //ViewHolder配置 继承RecyclerView的ViewHolder\n    static class ViewHolder extends RecyclerView.ViewHolder{\n        TextView objName;\n\n        public ViewHolder(@NonNull View itemView) {\n            super(itemView);\n            objName = (TextView) itemView.findViewById(R.id.name);\n        }\n    }\n\n    //构造函数\n    public ListAdapter(List<ListObject> mList) {\n        this.mList = mList;\n    }\n\n\n    //为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder\n    @NonNull\n    @Override\n    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.list_item,parent,false);\n        ViewHolder vh = new ViewHolder(view);\n        return vh;\n    }\n\n    //适配渲染数据到View中\n    @Override\n    public void onBindViewHolder(@NonNull final ViewHolder holder, int position) {\n        final ListObject listObj = mList.get(position);\n        holder.objName.setText(listObj.getName());\n        holder.itemView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Toast.makeText(view.getContext(),\"你点击了\" + listObj.getName(),Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n\n    //统计所有项\n    @Override\n    public int getItemCount() {\n        return mList.size();\n    }\n\n}\n\n\n```\n\n写完适配器，要开始使用它了。\n\n在MainActivity中设置。\n\n**前面提到两个必须:**\n\n1.必须指定一个适配器Adapter\n\n2.必须指定一个布局管理器LayoutManager\n\n代码如下，我已经标注出必选和可选:\n\n```java\n\npackage com.droidye.droidreview;\n\nimport androidx.appcompat.app.AppCompatActivity;\nimport androidx.recyclerview.widget.DefaultItemAnimator;\nimport androidx.recyclerview.widget.LinearLayoutManager;\nimport androidx.recyclerview.widget.RecyclerView;\n\nimport android.os.Bundle;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MainActivity extends AppCompatActivity {\n    private List<ListObject> listObj = new ArrayList<>();\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        //将item添加进去\n        initObjs();\n        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);\n        //设置布局管理器为线性布局管理器(必选)\n        recyclerView.setLayoutManager(new LinearLayoutManager(this));\n        //设置适配器(必选)\n        recyclerView.setAdapter(new ListAdapter(listObj));\n        //设置Item添加和删除的动画(可选)\n        recyclerView.setItemAnimator(new DefaultItemAnimator());\n    }\n\n     private void initObjs(){\n         for(int i = 0; i < 20; i ++){\n             ListObject listItem = new ListObject(\"Test\");\n             listObj.add(listItem);\n         }\n     }\n}\n\n```\n\n编写完这些代码，RecyclerView已经能够使用，在模拟器运行效果如下:\n\n![](http://cdn.yeliheng.com/WX20200229-155147%402x.png)\n\n这就是RecyclerView的基础实现，RecyclerView的功能十分强大，后期我们还可以使用它完整ListView无法完成的横向布局以及瀑布布局，以及动态添加item等等...\n', 'eae0ed06.html', 1, 980, 446, 4, '2020-02-29 23:30:00', '2020-02-29 23:30:00');
INSERT INTO `article` VALUES (16, 1, 2, '[公益项目]用unity引擎呈现疫情大数据', '疫情地球大数据', '# 下载地址 #\n\n[点击下载 版本: v1.2.0](http://cdn.yeliheng.com/%E7%96%AB%E6%83%85%E5%9C%B0%E7%90%83_Final_v1.2.zip)\n\n注: 项目作为学习用途，源代码仍可通过GitHub查看，亦可自行编译运行\n\n\n# 正文 #\n\n这次的疫情对人类来说是一次灾难，渺小的我不知该如何是好。我希望能够通过写程序来为社会贡献一份自己微薄的力量。经过几天的思考，我决定使用Unity3D疫情和C#做一个疫情地球大数据。爆肝3天，初版已经完成。(半)成品如图所示(由于时间仓促，UI我没有加上,感兴趣的基友可以前往我的github克隆并添加，文章末尾会放出开源地址)\n![](http://cdn.yeliheng.com/1405923_672f85b3_7664_3494%402217x1506.png.m.jpg)\n这个疫情可视化的地球可以直观地看出各个地区的疫情分布情况，中国精确到省份，外国精确到全国(以首都为国家位置)。使用Unity 粒子系统来进行数据的渲染，白色最轻，接着是黄色，严重是红色。粒子的密度和颜色的深浅可以反映出一个地区的严重程度。地球是可以用鼠标拖动的，滚轮可缩放。\n\n![](http://cdn.yeliheng.com/1405923_672f85b3_7664_3494%402217x1506.png.m.jpg)\n\n![](http://cdn.yeliheng.com/1405923_0d2c3a9e_7664_35%403840x2160.jpeg.m.jpg)\n\n接下来说说项目的开发流程。其实在开发的过程中，遇到很多大大小小的坑，也不是那么容易。\n首先是地球场景的构建。我直接采用一个球体，调整到合适的大小，并贴上世界地图的贴图。(贴图的资源来源于互联网，不用于任何商业用途，侵删！)。\n接着就是最关键的环节: 数据的获取与数据的渲染。\n数据接口是来自腾讯新闻的疫情大数据，可以获取到全球的所有疫情数据。疫情的数据已经拿到， 但是拿到的数据只有地区和确诊人数，要如何将它们渲染到球体上呢？\n\n![](http://cdn.yeliheng.com/1405923_bbb5fc12_7664_3502%403645x1632.png.m.jpg)\n\n这个问题困扰了我一段时间。因为我的球体采用简单的建模方式，并没有数据在上面，手动一个地区一个地区放置是绝对不可能完成的。所以后面我采用了一种方法：先获取各个地区的经纬度信息，再将经纬度转换成球体坐标，将数据以粒子的形式进行渲染。\n\n![](http://cdn.yeliheng.com/1405923_1ae914b7_7664_3504%403776x1707.png.m.jpg)\n\n经纬度的数据来源于Google地图云服务，由于Google有日请求量限制，所以我做了缓存，仅在有改动时才会进行请求。\n在拿到经纬度数据后，我尝试将它转换为unity中对应的球体坐标。这个环节我卡了好久，因为我进行了好多计算，都没办法精确地将数据渲染到具体位置。经过我的不懈努力，和查阅了大量关于球体坐标的资料后，我终于成功了哈哈哈(我太难了~)\n\n![](http://cdn.yeliheng.com/1405923_067c404b_7664_3506%403425x1115.png.m.jpg)\n\n数据可以精确地渲染到全球的各个地区，并且如果有新的确诊案例，地图上会自动渲染数据。\n本项目已开源，希望能尽自己的一分微薄之力，与大家一同共渡难关。\n\n![](http://cdn.yeliheng.com/1405923_47e8e8fe_7664_3508%402364x1388.png.m.jpg)\n\n开源仓库地址: [https://github.com/yeliheng/NcovEarth](https://github.com/yeliheng/NcovEarth)\n\n真希望这场疫情快点过去。感谢医学工作者在前线默默地奉献着自己的生命，向你们致敬！辛苦了！！！\n武汉加油！中国加油！世界加油！大家齐心协力，定能共渡难关！待到春暖花开时，我们再一起共赏祖国的大好河山！！！', '78f2028a.html', 1, 1004, 1332, 4, '2020-03-11 02:54:00', '2020-03-11 02:54:00');
INSERT INTO `article` VALUES (17, 1, 1, 'Springboot下通过Jpa连接MySQL数据库实现ORM对象关系映射', 'Springboot下通过Jpa连接MySQL数据库实现ORM对象关系映射', '# Springboot下通过Jpa连接MySQL数据库实现ORM对象关系映射 #\n\n\n## 1.1 依赖的搭建 ##\n\n\n要在Springboot中使用Jpa首先要引入项目依赖，这里以Maven为例: \n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>6.0.6</version>\n</dependency>\n```\n\n##  1.2 配置数据源 ##\n\n\n等到Maven Sync完成后，我们需要在**application.properties**文件中配置数据源。\n\n```properties\n# 注释: 在jdbc的url中，需要注意: \n# 编码设置为utf-8\n# 时区需要手动指定，否则在使用系统自动管理的Timestamp时会出现时间与北京时间相差11小时左右\nspring.datasource.url=jdbc:mysql://数据库IP:端口/数据库名称?charset=utf8mb4&useSSL=false&serverTimezone=Asia/Shanghai\nspring.datasource.username=你的用户名\nspring.datasource.password=你的密码\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n# 在Springboot版本>=2.0,请根据需要将数据库引擎切换为InnoDB\nspring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect\n# 是否在控制台输出sql语句\nspring.jpa.show-sql=true\n# 自动生成ddl语句\n# 这里需要解释一下常用参数: \n# create: 每次加载Hibernate时删除数据库中所有的数据和表，再重新创建新的(慎用!)\n# update: 当表不存在时自动创建数据表，当表存在时自动根据model更新表的结构，表中的数据保持不变。(常用)\n# (注意:当model中的字段被删除时，update模式是不会删除字段的)\n# validate: 每次加载Hibernate时比对表的结构，根据model自动做出修改,!但是新的表不会被创建!\nspring.jpa.hibernate.ddl-auto=update\n```\n\n## 1.3 开始使用 ##\n\n> 在开始使用之前，如果你使用的是IntelliJ IDEA，那么我可能要跟你唠嗑一下它的数据源机制。\n\n*在你还未配置Data Source前，写DO类，会出现Table画横线报错的情况，如图所示*\n\n![报错信息](https://cdn.yeliheng.com/WX20201116-151256%402x.png)\n\n*这个错还不是警告，直接画红标出，看着贼难受。所以，这时候需要配置一个数据源。在最右侧的侧边栏点击Database->加号->Data Source->MySQL，然后根据提示填写信息，完成后同步一下就ok了*\n\n![数据源配置](https://cdn.yeliheng.com/datasource.png)\n\n> 唠嗑结束，回到正题\n\n### 1.3.1 数据实体类的创建 ###\n\n首先，需要创建数据实体类。这里以User表的实体类为例:  (UsersDO.java)\n\n```java\npackage com.yeliheng.test.domain;\n\nimport org.hibernate.annotations.CreationTimestamp;\nimport org.hibernate.annotations.UpdateTimestamp;\n\nimport javax.persistence.*;\nimport java.time.LocalDateTime;\n\n@Entity\n@Table(name = \"users\")\npublic class UsersDO {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private long id;\n    @Column\n    private String nickname;\n    @Column\n    private String phone;\n    @Column\n    private String password;\n    @CreationTimestamp\n    private LocalDateTime createDateTime;\n    @UpdateTimestamp\n    private LocalDateTime updateDateTime;\n\n    public String getNickname() {\n        return nickname;\n    }\n\n    public void setNickname(String nickname) {\n        this.nickname = nickname;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public LocalDateTime getCreateDateTime() {\n        return createDateTime;\n    }\n\n    public void setCreateDateTime(LocalDateTime createDateTime) {\n        this.createDateTime = createDateTime;\n    }\n\n    public LocalDateTime getUpdateDateTime() {\n        return updateDateTime;\n    }\n\n    public void setUpdateDateTime(LocalDateTime updateDateTime) {\n        this.updateDateTime = updateDateTime;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n}\n\n```\n\n这里对以上代码的关键点进行解释：\n\n@Entity 注解：用于数据库的实体类均需要加上Entity注解\n\n@Table 注解：顾名思义，这是一个表注解，可在name属性中赋值需要的表名。默认表名与类名相同\n\n@Id : 表示主键ID，如果想让id自增则需要再加上@GeneratedValue(strategy = GenerationType.IDENTITY)注解\n\n@Column 注解：表示这是一个字段\n\n这里，我们希望将数据的创建时间与更新时间交给框架来管理，则我们需要加上**@CreationTimestamp**和**@UpdateTimestamp**注解。并将数据类型定义为**LocalDateTime**。\n\n这样有什么好处？首先，我们无需在数据更新时自行去实现时间更新的逻辑，用户的注册时间以及更改时间完全交付给系统管理，提供很大的便利。其次，我们无需自行格式化时间戳，因为Jpa的时间戳与MySQL的时间戳有格式上的不同，在格式化的过程中，极其容易踩坑。\n\n### 1.3.2 开始与数据库进行交互(Dao层的创建) ###\n\n首先解释一下什么叫DAO层\n\nDAO即Data Access Object，能够实现对数据持久化的访问。不止是数据库，持久化的数据例如文件的操作，都可在DAO层进行。也算是一种规范。简单地说，DAO层**用于隔离业务逻辑代码和数据访问代码，隔离不同数据的实现。**多说无用，直接开始增删改查。\n\nJpa已经帮忙封装完Dao层的相关代码，所以，我们实现增删改查十分容易。只需要定义一个接口，这个接口继承自**org.springframework.data.repository.Repository<T, ID>** 接口，一句话即可完成初始化。T表示数据的实体类，例如我们的UsersDO类，ID表示实体类的主键类型。最后，别忘了加上**@Respository**这个注解，这个注解用于表示存储层Bean。代码如下:\n\n```java\npackage com.yeliheng.test.dao;\n\nimport com.yeliheng.test.domain.UsersDO;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface UsersDao extends JpaRepository<UsersDO,Long> {\n    Boolean existsByPhone(String phone);\n    UsersDO findByPhone(String phone);\n}\n\n```\n\n我们在定义完接口后，在接口中实现了两个方法：顾名思义，一个是通过手机号判断用户是否存在，一个是通过手机号查找用户。\n\n就这么简单，Jpa就可以实现查询功能。\n\n稍微提一下方法名称: \n\nfindByXXX：XXX表示你要查什么字段。你甚至可以findByXXXAndXXXAndXXXAndXXX......多少字段都没问题，中间用And进行连接。超级方便。\n\nexists同理。\n\n这里仅仅列举了两种操作，Jpa的接口功能十分强大， 可自行定制使用其他功能，例如排序、分页、多表联查等等等等...用户自行查表获取。\n\n### 1.3.3 在service里调用 ###\n\n#### 增 ####\n\n通俗易懂，直接上代码。\n\n```java\n@Autowired\nprivate UsersDao usersDao;\npublic void addUser(){\n  UsersDO usersDO = new UsersDO();\n  usersDO.setPhone(\"11111111111\");\n  usersDO.setPassword(\"h3khj1￥sdjs%#0x/!%$#dsjd!a!/1#@!\");\n  usersDao.save(usersDO);\n}\n```\n\n#### 删 ####\n\n```java\n@Autowired\nprivate UsersDao usersDao;\npublic void deleteUser(){\n  UsersDO usersDO = usersDao.findByPhone(\"1111111111\");\n  usersDao.delete(usersDO);\n}\n```\n\n#### 改 ####\n\n与增的方法相同，就是多一步查找出UsersDO的实例，再调用set方法进行设置，最后save即可。\n\n```java\n@Autowired\nprivate UsersDao usersDao;\npublic void updateUser(){\n  UUsersDO usersDO = usersDao.findByPhone(\"1111111111\");\n  usersDO.setPhone(\"12222222222\");\n  usersDao.save(usersDO);\n}\n```\n\n\n\n#### 查 ####\n\n```java\n@Autowired\nprivate UsersDao usersDao;\npublic void queryUser(){\n  UsersDO usersDO = usersDao.findByPhone(\"1111111111\");\n}\n```\n\n## 预告 ##\n\n下一篇，我将讲讲我在Filter过滤器中使用Dao层踩的坑。', '31c82676.html', 1, 1607, 336, 6, '2020-11-16 23:57:00', '2020-11-16 23:57:00');
INSERT INTO `article` VALUES (18, 1, 2, '[开源项目]快速构建Oculus开发环境和基本交互', '帮助你快速实现指针曲线、传送、手部模型甚至攀爬等交互', '# oculus-base-setup\n\n## [仓库地址](https://github.com/yeliheng/oculus-base-setup) ##\n\n# 0X01 这个仓库有什么用？ #\n\n通过这个仓库你可以在unity快速配置Oculus的开发环境。并且这个仓库中包含了Oculus quest/quest2的基本交互。如：控制器按钮交互、手部模型交互、贝塞尔曲线指针、传送。并且可在原来的基础上简单地进行攀爬，抓取等动作拓展。\n\n# 0X02 参数说明 #\n\n1. 运行环境：Unity 2019.x\n\n2. 测试设备：Oculus Quest/Quest2、Oculus Rift（上述设备已通过测试，其他型号的设备请自行测试）\n\n3. 依赖说明：本项目用到以下包(Packages)，按照从属关系列出：\n\n   > Malimbe\n   >\n   > >Zinnia\n   > >\n   > >> VRTK\n\n   以及最基本的Oculus Integration(在Unity的Asset Store下载)\n\n   下文会给出Packages的下载地址。\n\n#  0X03 开始使用 #\n\n1. 克隆本仓库\n\n   `git clone https://github.com/yeliheng/oculus-base-setup.git`\n\n2. 用Unity打开本项目\n\n3. 添加依赖。\n\n   3.1.在Unity Asset Store下载Oculus Integration库，按照提示Upgrade和Restart。\n\n   3.2.按照0X02的依赖说明依次导入所需的Package。顺序依次是：Malimbe->Zinnia->VRTK\n\n   （导入包在Unity的操作：点击Window->Package Manager->+->Add package from disk->选择package.json文件即可）\n\n   依赖包下载地址：\n\n   链接：https://pan.baidu.com/s/11QO8DMKYVvK2jJB8IS2tlA \n   提取码：lw1i \n\n4. 进入play mode 体验。Enjoy yourself!\n\n0X04 项目截图\n\n![手模](https://cdn.yeliheng.com/%E6%89%8B%E6%A8%A1.png)\n\n![传送和指针](https://cdn.yeliheng.com/%E4%BC%A0%E9%80%81%E5%92%8C%E6%8C%87%E9%92%88.png)\n\n\n\n0X05 [Yeliheng的技术小站](https://www.yeliheng.com)\n\n', '901ae64b.html', 1, 384, 116, 2, '2021-02-07 04:13:00', '2021-02-07 04:13:00');
INSERT INTO `article` VALUES (19, 1, 7, 'Git工具-重写历史: 如何在提交后修改Commit的内容?', '时间机器，重写历史', '# 介绍 #\n\n这篇文章是我在遇到问题后查询git官方文档时看到的，对我帮助颇大，故整理分享出来。\n\n原文地址：https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2\n\n许多时候，在使用 Git 时，你可能想要修订提交历史。\nGit 很棒的一点是它允许你在最后时刻做决定。\n你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 `git stash` 来决定不与某些内容工作，\n也可以重写已经发生的提交就像它们以另一种方式发生的一样。\n这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分，\n或完全地移除提交——在将你的工作成果与他人共享之前。\n\n在本文中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\n\n\n**在满意之前不要推送你的工作**\n\nGit 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 *在本地* 随便重写历史记录。\n然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。\n\n> 简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\n\n\n# 修改最后一次提交 #\n\n修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。\n对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息，\n或者通过添加、移除或修改文件来更改提交实际的内容。\n\n如果，你只是想修改最近一次提交的提交信息，那么很简单：\n\n`$ git commit --amend`\n\n上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。\n当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\n\n另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改，\n暂存它们，然后用 `git commit --amend` 以新的改进后的提交来 *替换* 掉旧有的最后一次提交，\n\n使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。\n它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\n\n> .修补后的提交可能需要修补提交信息\n\n当你在修补一次提交时，可以同时修改提交信息和提交内容。\n如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。\n\n另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件），\n那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：\n\n`$ git commit --amend --no-edit`\n\n# 修改多个提交信息 #\n\n为了修改在提交历史中较远的提交，必须使用更复杂的工具。\nGit 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。\n通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。\n可以通过给 `git rebase` 增加 `-i` 选项来交互式地运行变基。\n必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\n\n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息，\n将想要修改的最近一次提交的父提交作为参数传递给 `git rebase -i` 命令，即  `HEAD~2^` 或 `HEAD~3`。\n记住 `~3` 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：\n\n`$ git rebase -i HEAD~3`\n\n再次记住这是一个变基命令——在 `HEAD~3..HEAD` 范围内的每一个修改了提交信息的提交及其 *所有后裔* 都会被重写。\n不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。\n\n运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：\n\n```\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n# Rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit\'s log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with \'git rebase --continue\')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit\'s\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c <commit> to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n```\n\n需要重点注意的是相对于正常使用的 `log` 命令，这些提交显示的顺序是相反的。\n运行一次 \'log\' 命令，会看到类似这样的东西：\n\n```\n$ git log --pretty=format:\"%h %s\" HEAD~3..HEAD\na5f4a0d added cat-file\n310154e updated README formatting and added blame\nf7f3f6d changed my name a bit\n```\n\n注意其中的反序显示。\n交互式变基给你一个它将会运行的脚本。\n它将会从你在命令行中指定的提交（`HEAD~3`）开始，从上到下的依次重演每一个提交引入的修改。\n它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。\n\n你需要修改脚本来让它停留在你想修改的变更上。\n要达到这个目的，你只要将你想修改的每一次提交前面的 `pick\' 改为 `edit\'。\n例如，只想修改第三次提交信息，可以像下面这样修改文件：\n\n```\nedit f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n```\n\n当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：\n\n```\n$ git rebase -i HEAD~3\nStopped at f7f3f6d... changed my name a bit\nYou can amend the commit now, with\n\n       git commit --amend\n\nOnce you\'re satisfied with your changes, run\n\n       git rebase --continue\n```\n\n这些指令准确地告诉你该做什么。\n输入\n\n`$ git commit --amend`\n\n修改提交信息，然后退出编辑器。\n然后，运行\n\n`$ git rebase --continue`\n\n这个命令将会自动地应用另外两个提交，然后就完成了。\n如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。\n每一次，Git 将会停止，让你修正提交，然后继续直到完成。\n\n# 重新排序提交 #\n\n也可以使用交互式变基来重新排序或完全移除提交。\n如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：\n\n```\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n```\n\n改为这样：\n\n```\npick 310154e updated README formatting and added blame\npick f7f3f6d changed my name a bit\n```\n\n当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 `310154e` 然后应用 `f7f3f6d`，最后停止。\n事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。\n\n# 压缩提交 #\n\n通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。\n在变基信息中脚本给出了有用的指令：\n\n```\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit\'s log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with \'git rebase --continue\')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit\'s\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c <commit> to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n```\n\n如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。\n所以，如果想要这三次提交变为一个提交，可以这样修改脚本：\n\n```\npick f7f3f6d changed my name a bit\nsquash 310154e updated README formatting and added blame\nsquash a5f4a0d added cat-file\n```\n\n当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：\n\n```\n# This is a combination of 3 commits.\n# The first commit\'s message is:\nchanged my name a bit\n\n# This is the 2nd commit message:\n\nupdated README formatting and added blame\n\n# This is the 3rd commit message:\n\nadded cat-file\n```\n\n当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。\n\n# 拆分提交 #\n\n拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。\n例如，假设想要拆分三次提交的中间那次提交。\n想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。\n可以通过修改 `rebase -i` 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：\n\n```\npick f7f3f6d changed my name a bit\nedit 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n```\n\n然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。\n当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（`f7f3f6d`），\n应用第二个提交（`310154e`），然后让你进入命令行。\n那里，可以通过 `git reset HEAD^` 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。\n现在可以暂存并提交文件直到有几个提交，然后当完成时运行 `git rebase --continue`：\n\n```\n$ git reset HEAD^\n$ git add README\n$ git commit -m \'updated README formatting\'\n$ git add lib/simplegit.rb\n$ git commit -m \'added blame\'\n$ git rebase --continue\n```\n\nGit 在脚本中应用最后一次提交（`a5f4a0d`），历史记录看起来像这样：\n\n```\n$ git log -4 --pretty=format:\"%h %s\"\n1c002dd added cat-file\n9b29157 added blame\n35cfb2b updated README formatting\nf3cc40e changed my name a bit\n```\n\n再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。\n\n# 核武器级选项：filter-branch #\n\n有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。\n这个命令是 `filter-branch`，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。\n然而，它可以很有用。\n你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\n\n`git filter-branch` 有很多陷阱，不再推荐使用它来重写历史。\n请考虑使用 `git-filter-repo`，它是一个 Python 脚本，相比大多数使用 `filter-branch`\n的应用来说，它做得要更好。它的文档和源码可访问 [https://github.com/newren/git-filter-repo](https://github.com/newren/git-filter-repo) 获取。\n\n# 从每一个提交中移除一个文件 #\n\n这经常发生。\n有人粗心地通过 `git add .` 提交了一个巨大的二进制文件，你想要从所有地方删除。\n可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。\n`filter-branch` 是一个可能会用来擦洗整个提交历史的工具。\n为了从整个提交历史中移除一个叫做 `passwords.txt` 的文件，可以使用 `--tree-filter` 选项给 `filter-branch`：\n\n```\n$ git filter-branch --tree-filter \'rm -f passwords.txt\' HEAD\nRewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\nRef \'refs/heads/master\' was rewritten\n```\n\n`--tree-filter` 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。\n在本例中，你从每一个快照中移除了一个叫作 `passwords.txt` 的文件，无论它是否存在。\n如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 `git filter-branch --tree-filter \'rm -f *~\' HEAD` 的命令。\n\n最后将可以看到 Git 重写树与提交然后移动分支指针。\n通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 `master` 分支。\n为了让 `filter-branch` 在所有分支上运行，可以给命令传递 `--all` 选项。\n\n# 使一个子目录做为新的根目录 #\n\n假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（`trunk`、`tags` 等等）。\n如果想要让 `trunk` 子目录作为每一个提交的新的项目根目录，`filter-branch` 也可以帮助你那么做：\n\n```\n$ git filter-branch --subdirectory-filter trunk HEAD\nRewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\nRef \'refs/heads/master\' was rewritten\n```\n\n现在新项目根目录是 `trunk` 子目录了。\nGit 会自动移除所有不影响子目录的提交。\n\n# 全局修改邮箱地址 #\n\n另一个常见的情形是在你开始工作时忘记运行 `git config` 来设置你的名字与邮箱地址，\n或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。\n任何情形下，你也可以通过 `filter-branch` 来一次性修改多个提交中的邮箱地址。\n需要小心的是只修改你自己的邮箱地址，所以你使用 `--commit-filter`：\n\n```\n$ git filter-branch --commit-filter \'\n        if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ];\n        then\n                GIT_AUTHOR_NAME=\"Scott Chacon\";\n                GIT_AUTHOR_EMAIL=\"schacon@example.com\";\n                git commit-tree \"$@\";\n        else\n                git commit-tree \"$@\";\n        fi\' HEAD\n```\n\n这会遍历并重写每一个提交来包含你的新邮箱地址。\n因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和，\n而不仅仅只是那些匹配邮箱地址的提交。', '534e9ad.html', 1, 3904, 435, 16, '2021-02-07 04:43:02', '2021-02-07 04:43:02');
INSERT INTO `article` VALUES (22, 1, 9, 'Yeliheng的技术小站正式开源！', 'Yeliheng-Blog已开源，欢迎二次开发！本篇文章将详细介绍本站系统以及搭建教程。', '> Yeliheng-Blog说明在[GitHub](https://github.com/yeliheng/yeliheng-blog/)上同步更新，地址:[https://github.com/yeliheng/yeliheng-blog](https://github.com/yeliheng/yeliheng-blog)\n>\n> 欢迎Star，Issue，Pull requests以及任何对本项目的贡献。开发不易，感谢支持！\n\n# 系统介绍\n\n这个开源仓库是Yeliheng的技术小站的前后端实现。Yeliheng-Blog是一个基于SpringBoot + Vue3开发的前后端分离的完整博客系统。它并不仅仅是一个简单的博客系统，更是一个**后台权限管理系统**，通过**模块化**使其具有高拓展性，可拓展成任何您想要的管理系统，例如文章系统，OA办公系统，仓库管理系统等...\n\n## 特性\n\n- 轻量化系统，无外部框架的重度依赖\n\n- 良好的可拓展性\n\n- 响应式前端网页，完全适配移动端以及不同分辨率设备\n\n- 基于RBAC模型的权限管理系统\n\n- 优质的用户体验\n\n  ...\n\n## 在线地址\n\n后台演示功能暂未完成，目前仅开放前台展示，后台系统可自行搭建体验。[点击查看搭建教程](#搭建教程)\n\n前台演示地址: [https://www.yeliheng.com](https://www.yeliheng.com)\n\n后台搭建教程：[点击查看搭建教程](#搭建教程)\n\n# 功能详解\n\n## 后台\n\n### 目前已有功能\n\n- 文章管理：实现文章的增删改查，以及文章分类、标签，隐私性的设置。\n\n- 用户管理：用户登录、注册以及管理员对用户的增删改查操作。\n\n- 角色管理：对角色系统的增删改查以及为用户分配多个角色。\n\n- 权限管理：可为不同角色分配所需的不同权限。\n\n- 菜单管理：为角色分配菜单权限，以及前端菜单的动态路由处理。\n\n- 站点统计：目前仅实现对文章字数，阅读时长及字数的统计，后续将以模块化形式实现站点的完整统计功能。\n\n### 正在开发中的功能\n\n- 对菜单的动态增加以及修改，自定义菜单类型（如：放置外链或多媒体类型等功能）\n\n- 评论管理模块\n\n- 完整的站点统计模块\n\n- 定时备份模块的开发\n\n- API接口文档\n\n---\n\n## 前台\n\n### 目前已有功能\n\n- 基于Markdown和Github风格的文章查看器\n\n- 按照分类索引文章\n\n- 按照标签索引文章\n\n- 基于Three.js实现的Header\n\n- 站点信息的显示\n\n- 关于页面\n\n### 正在开发的功能\n\n- 评论模块\n\n- 日夜间模式的切换\n\n- 站点统计模块\n\n---\n\n# 工程结构\n\n```\nyeliheng-blog\n├── blog-common    --  后端系统通用模块（封装各种工具类、公共常量、异常类等）\n├── blog-framework --  后端系统框架层（封装框架相关工具，如权限工具，框架配置文件，安全相关类）\n├── blog-system    --  博客系统核心业务层（服务，数据库访问）\n├── blog-web       --  博客系统API控制器（controller）\n└── blog-vue       --  博客系统前端模块（Vue3）\n    ├── admin   --  博客系统前端后台模块\n    └── blog    --  博客系统前端前台模块\n```\n\n![模块图](https://cdn.yeliheng.com/yeliheng-blog/module.png)\n\n# 技术栈\n\n| 技术                 | 说明                |\n| -------------------- | ------------------- |\n| SpringBoot           | 容器+框架           |\n| SpringSecurity       | 认证/权限框架       |\n| MyBatis              | ORM框架             |\n| RabbitMQ             | 消息队列            |\n| Redis                | 分布式缓存          |\n| Nginx                | 静态资源服务器      |\n| Docker               | 应用容器引擎        |\n| Jenkins              | 自动化部署工具      |\n| Druid                | 数据库连接池        |\n| OSS                  | 对象存储            |\n| JWT                  | JWT登录支持         |\n| PageHelper           | MyBatis物理分页插件 |\n| Swagger-UI           | 文档生成工具        |\n| Hibernator-Validator | 验证框架            |\n| Vue3                 | 渐进式js框架        |\n| Sass                 | css扩展语言         |\n| Element-UI           | 饿了么UI库          |\n| Markdown-it          | markdown解析工具    |\n\n# 搭建教程\n\n## 开发环境\n\n在开始之前，请确认您的开发环境，尽量与此处保持一致，以免出现意料之外的问题。\n\n### 后端\n\n| 开发环境 | 版本   |\n| -------- | ------ |\n| JDK      | 1.8    |\n| JRE      | 1.8    |\n| MySQL    | 5.7    |\n| Redis    | >= 3.x |\n\n### 前端\n\n| 开发环境 | 版本     |\n| -------- | -------- |\n| Vue      | >= 3     |\n| Node.js  | >= 14.18 |\n| npm      | >= 6.14  |\n\n## 快速开始\n\n### 后端\n\n1、搭建如上表格所示的开发环境并确保所有环境处于正常运行状态。（具体过程此处不做赘述，可自行查阅相关资料）\n\n2、克隆本项目\n\n```\ngit clone https://github.com/yeliheng/yeliheng-blog.git\n```\n\n3、导入idea或其他IDE，等待Maven导入所有的包。（此过程可能需要一些时间，部分国外仓库加载较慢，建议使用国内镜像源，具体步骤可自行在搜索引擎上查看）\n\n4、在blog-web包下新建配置文件，文件名为：**application-dev.yml**，并将**application-example.yml**中的内容复制到刚刚创建的**application-dev.yml**中，并将datasource中的数据源修改为自己的数据库信息。\n\n5、导入数据库\n\n将项目根目录下的**yeliheng-blog.sql**文件导入到数据库中。\n\n6、准备完成，开始运行项目！\n\n当您看到如下提示，代表项目已成功运行。\n\n![成功](https://cdn.yeliheng.com/yeliheng-blog/success.png)\n\n### 前端\n\n1、进入本项目中的blog-vue文件夹中，前端分为admin和blog两个模块，此处以admin模块为例进行说明。\n\n2、我们首先进入admin文件夹，admin文件夹中新建文件：**.env.development**，并将**.env.example**中的内容复制到刚刚创建的**.env.development**中，并将**VUE_APP_BASE_API**地址修改为后端地址。若您没有改动后端地址则无需更改。\n\n3、执行如下指令安装所需依赖：\n\n```\nnpm install\n```\n\n4、等待上述指令执行完成后，执行以下指令：\n\n```\nnpm run serve\n```\n\n5、项目成功运行，开始访问吧！\n\n**blog模块的安装方法与上述过程完全相同**\n\n# 项目截图\n\n![首页](https://cdn.yeliheng.com/yeliheng-blog/index.png)\n\n\n\n![文章](https://cdn.yeliheng.com/yeliheng-blog/article.png)\n\n![后台](https://cdn.yeliheng.com/yeliheng-blog/admin-article-list.png)\n\n![权限管理](https://cdn.yeliheng.com/yeliheng-blog/admin-role-manage.png)\n\n', 'f1d1e1d9', 1, 1462, 259, 6, '2022-01-05 01:46:39', '2022-01-05 15:51:35');
COMMIT;

-- ----------------------------
-- Table structure for article_tag
-- ----------------------------
DROP TABLE IF EXISTS `article_tag`;
CREATE TABLE `article_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) NOT NULL COMMENT '文章id',
  `tag_id` bigint(20) NOT NULL COMMENT '标签id',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=55 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of article_tag
-- ----------------------------
BEGIN;
INSERT INTO `article_tag` VALUES (1, 5, 2, '2022-01-04 16:43:49', '2022-01-04 16:43:49');
INSERT INTO `article_tag` VALUES (45, 22, 1, '2022-01-05 15:51:35', '2022-01-05 15:51:35');
INSERT INTO `article_tag` VALUES (46, 22, 3, '2022-01-05 15:51:35', '2022-01-05 15:51:35');
INSERT INTO `article_tag` VALUES (47, 22, 2, '2022-01-05 15:51:35', '2022-01-05 15:51:35');
INSERT INTO `article_tag` VALUES (48, 22, 4, '2022-01-05 15:51:35', '2022-01-05 15:51:35');
INSERT INTO `article_tag` VALUES (49, 22, 5, '2022-01-05 15:51:35', '2022-01-05 15:51:35');
INSERT INTO `article_tag` VALUES (50, 22, 6, '2022-01-05 15:51:35', '2022-01-05 15:51:35');
INSERT INTO `article_tag` VALUES (51, 22, 7, '2022-01-05 15:51:35', '2022-01-05 15:51:35');
INSERT INTO `article_tag` VALUES (52, 10, 2, '2022-01-11 12:02:51', '2022-01-11 12:02:51');
INSERT INTO `article_tag` VALUES (53, 10, 3, '2022-01-11 12:02:51', '2022-01-11 12:02:51');
INSERT INTO `article_tag` VALUES (54, 10, 4, '2022-01-11 12:02:51', '2022-01-11 12:02:51');
COMMIT;

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '分类id',
  `user_id` bigint(20) NOT NULL COMMENT '创建者id',
  `category_name` varchar(20) NOT NULL COMMENT '分类名称',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of category
-- ----------------------------
BEGIN;
INSERT INTO `category` VALUES (1, 1, 'Java', '2022-01-01 13:33:19', '2022-01-01 13:33:19');
INSERT INTO `category` VALUES (2, 1, 'VR', '2022-01-01 13:33:25', '2022-01-01 13:33:25');
INSERT INTO `category` VALUES (3, 1, 'Linux', '2022-01-01 13:33:30', '2022-01-01 13:33:30');
INSERT INTO `category` VALUES (4, 1, 'C', '2022-01-01 13:33:38', '2022-01-01 13:33:38');
INSERT INTO `category` VALUES (5, 1, '杂文记事', '2022-01-01 13:33:44', '2022-01-01 13:33:44');
INSERT INTO `category` VALUES (6, 1, 'Android', '2022-01-01 13:33:52', '2022-01-01 13:33:52');
INSERT INTO `category` VALUES (7, 1, 'Git', '2022-01-01 13:36:40', '2022-01-01 13:36:40');
INSERT INTO `category` VALUES (8, 1, '捣鼓', '2022-01-01 14:13:38', '2022-01-01 14:13:38');
INSERT INTO `category` VALUES (9, 1, '博客系统', '2022-01-04 17:30:10', '2022-01-04 17:30:23');
COMMIT;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `user_id` bigint(20) DEFAULT NULL COMMENT '评论者id',
  `comment` varchar(255) NOT NULL COMMENT '评论内容',
  `verified` tinyint(1) DEFAULT '0' COMMENT '审核状态(-1:审核不通过 0:未审核 1:审核通过)',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of comment
-- ----------------------------
BEGIN;
COMMIT;

-- ----------------------------
-- Table structure for link
-- ----------------------------
DROP TABLE IF EXISTS `link`;
CREATE TABLE `link` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '友链id',
  `user_id` bigint(20) NOT NULL COMMENT '创建者id',
  `link_name` varchar(255) NOT NULL COMMENT '友链名称',
  `link_url` varchar(255) NOT NULL COMMENT '友链url',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of link
-- ----------------------------
BEGIN;
COMMIT;

-- ----------------------------
-- Table structure for menu
-- ----------------------------
DROP TABLE IF EXISTS `menu`;
CREATE TABLE `menu` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '创建者id',
  `parent_id` bigint(20) DEFAULT '0' COMMENT '父菜单id',
  `menu_name` varchar(255) NOT NULL COMMENT '菜单名称',
  `order_num` int(11) DEFAULT '100' COMMENT '排序',
  `path` varchar(255) DEFAULT '/#' COMMENT 'URL',
  `component` varchar(255) DEFAULT 'Home' COMMENT '组件地址',
  `hidden` tinyint(1) DEFAULT '0' COMMENT '可见性',
  `permission` varchar(255) DEFAULT NULL COMMENT '菜单权限',
  `icon` varchar(255) DEFAULT NULL COMMENT '菜单字体图标',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of menu
-- ----------------------------
BEGIN;
INSERT INTO `menu` VALUES (1, 1, 0, '首页', 0, '/dashboard', 'Home', 0, NULL, 'fa-dashboard', '2021-11-02 06:26:04', '2021-11-02 06:26:06');
INSERT INTO `menu` VALUES (2, 1, 0, '文章管理', 1, '/articles', 'Layout', 0, 'admin:articles:view', 'fa-file', '2021-10-29 18:48:46', '2021-10-29 18:48:46');
INSERT INTO `menu` VALUES (3, 1, 2, '发布文章', 0, '/articles/publish', 'article/Article', 0, 'admin:articles:add', 'fa-paper-plane', '2021-10-29 18:55:14', '2021-10-29 18:55:14');
INSERT INTO `menu` VALUES (4, 1, 2, '文章列表', 0, '/articles/list', 'article/ArticleList', 0, 'admin:articles:list', 'fa-file-text', '2021-10-29 18:55:57', '2021-10-29 18:55:57');
INSERT INTO `menu` VALUES (5, 1, 2, '修改文章', 0, '/articles/:id', 'article/Edit', 1, 'admin:articles:edit', NULL, '2021-11-14 06:23:28', '2021-11-14 06:23:28');
INSERT INTO `menu` VALUES (6, 1, 2, '删除文章', 0, '/#', 'Home', 1, 'admin:articles:delete', NULL, '2021-11-14 06:23:36', '2021-11-14 06:23:36');
INSERT INTO `menu` VALUES (7, 1, 2, '分类管理', 1, '/categories', 'category/Category', 0, 'admin:categories:view', 'fa-th', '2021-10-29 18:56:09', '2021-10-29 18:56:09');
INSERT INTO `menu` VALUES (8, 1, 7, '新增分类', 0, '/#', 'Home', 1, 'admin:categories:add', NULL, '2021-11-14 06:21:30', '2021-11-14 06:21:44');
INSERT INTO `menu` VALUES (9, 1, 7, '分类列表', 0, '/#', 'Home', 1, 'admin:categories:list', NULL, '2021-11-14 06:21:30', '2021-11-14 06:21:44');
INSERT INTO `menu` VALUES (10, 1, 7, '修改分类', 0, '/#', 'Home', 1, 'admin:categories:edit', NULL, '2021-11-14 06:21:10', '2021-11-14 06:21:10');
INSERT INTO `menu` VALUES (11, 1, 7, '删除分类', 0, '/#', 'Home', 1, 'admin:categories:delete', NULL, '2021-11-14 06:22:03', '2021-11-14 06:22:03');
INSERT INTO `menu` VALUES (12, 1, 2, '标签管理', 2, '/tags', 'tag/Tag', 0, 'admin:tags:view', 'fa-tags', '2021-10-29 18:56:22', '2021-10-29 18:56:22');
INSERT INTO `menu` VALUES (13, 1, 12, '新增标签', 0, '/#', 'Home', 1, 'admin:tags:add', NULL, '2021-11-14 06:24:07', '2021-11-14 06:24:07');
INSERT INTO `menu` VALUES (14, 1, 12, '标签列表', 0, '/#', 'Home', 1, 'admin:tags:list', NULL, '2021-11-14 06:24:07', '2021-11-14 06:24:07');
INSERT INTO `menu` VALUES (15, 1, 12, '修改标签', 0, '/#', 'Home', 1, 'admin:tags:edit', NULL, '2021-11-14 06:24:15', '2021-11-14 06:24:15');
INSERT INTO `menu` VALUES (16, 1, 12, '删除标签', 0, '/#', 'Home', 1, 'admin:tags:delete', NULL, '2021-11-14 06:24:25', '2021-11-14 06:24:25');
INSERT INTO `menu` VALUES (17, 1, 0, '用户管理', 2, '/users', 'Layout', 0, 'admin:users:view', 'fa-user', '2021-10-29 18:57:10', '2021-10-29 18:57:10');
INSERT INTO `menu` VALUES (18, 1, 17, '用户列表', 1, '/users/list', 'user/User', 0, 'admin:users:list', 'fa-users', '2021-10-29 18:58:54', '2021-10-29 18:58:54');
INSERT INTO `menu` VALUES (19, 1, 17, '新增用户', 0, '/#', 'Home', 1, 'admin:users:add', NULL, '2021-11-14 22:37:32', '2021-11-14 22:37:32');
INSERT INTO `menu` VALUES (20, 1, 17, '修改用户', 0, '/#', 'Home', 1, 'admin:users:edit', NULL, '2021-11-14 22:37:32', '2021-11-14 22:37:32');
INSERT INTO `menu` VALUES (21, 1, 17, '删除用户', 0, '/#', 'Home', 1, 'admin:users:delete', NULL, '2021-11-14 22:37:32', '2021-11-14 22:37:32');
INSERT INTO `menu` VALUES (22, 1, 0, '权限管理', 0, '/perm', 'Layout', 0, 'admin:perm:view', 'fa-shield', '2021-11-14 22:41:59', '2021-11-14 22:41:59');
INSERT INTO `menu` VALUES (23, 1, 22, '角色管理', 0, '/roles', 'role/Role', 0, 'admin:roles:list', 'fa-id-badge', '2021-11-14 22:49:27', '2021-11-14 22:49:27');
INSERT INTO `menu` VALUES (24, 1, 22, '新增角色', 0, '/roles', 'role/Role', 1, 'admin:roles:add', '', '2021-11-14 22:49:27', '2021-11-14 22:49:27');
INSERT INTO `menu` VALUES (25, 1, 22, '修改角色', 0, '/roles', 'role/Role', 1, 'admin:roles:edit', '', '2021-11-14 22:49:27', '2021-11-14 22:49:27');
INSERT INTO `menu` VALUES (26, 1, 22, '删除角色', 0, '/roles', 'role/Role', 1, 'admin:roles:delete', '', '2021-11-14 22:49:27', '2021-11-14 22:49:27');
INSERT INTO `menu` VALUES (27, 1, 0, '菜单管理', 0, '/menu', 'Layout', 0, 'admin:menus:view', 'fa-list-ul', '2021-11-15 22:23:41', '2021-11-15 22:23:45');
INSERT INTO `menu` VALUES (28, 1, 27, '新增菜单', 0, '/#', 'Home', 1, 'admin:menus:add', '', '2021-11-15 22:31:08', '2021-11-15 22:31:08');
INSERT INTO `menu` VALUES (29, 1, 27, '修改菜单', 0, '/#', 'Home', 1, 'admin:menus:edit', '', '2021-11-15 22:31:08', '2021-11-15 22:31:08');
INSERT INTO `menu` VALUES (30, 1, 27, '删除菜单', 0, '/#', 'Home', 1, 'admin:menus:delete', '', '2021-11-15 22:31:08', '2021-11-15 22:31:08');
INSERT INTO `menu` VALUES (31, 1, 0, '系统监控', 100, '/#', 'Layout', 0, NULL, 'fa-dashboard   ', '2022-01-28 18:59:14', '2022-01-28 19:08:29');
INSERT INTO `menu` VALUES (32, 1, 31, '数据库监控', 1, '/druid', 'monitor/Druid', 0, 'admin:monitor:druid', 'fa-database', '2022-01-28 19:03:18', '2022-01-28 19:08:38');
COMMIT;

-- ----------------------------
-- Table structure for notice
-- ----------------------------
DROP TABLE IF EXISTS `notice`;
CREATE TABLE `notice` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '公告id',
  `user_id` bigint(20) NOT NULL COMMENT '公告发起人',
  `content` varchar(255) NOT NULL COMMENT '公告内容',
  `level` tinyint(1) DEFAULT '0' COMMENT '紧急程度',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of notice
-- ----------------------------
BEGIN;
INSERT INTO `notice` VALUES (1, 1, '这是Yeliheng的个人博客,我会在这里分享我计算机学习生涯中的笔记、总结、技术干货...', 0, '2022-01-02 23:27:17', '2022-01-02 23:27:20');
COMMIT;

-- ----------------------------
-- Table structure for role
-- ----------------------------
DROP TABLE IF EXISTS `role`;
CREATE TABLE `role` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '角色id',
  `role_char` varchar(255) NOT NULL COMMENT '角色标识',
  `role_name` varchar(255) NOT NULL COMMENT '角色名称',
  `locked` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of role
-- ----------------------------
BEGIN;
INSERT INTO `role` VALUES (1, 'admin', '管理员', 0, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role` VALUES (2, 'test', '测试角色', 0, '2022-01-11 16:13:45', '2022-01-11 17:00:18');
COMMIT;

-- ----------------------------
-- Table structure for role_menu
-- ----------------------------
DROP TABLE IF EXISTS `role_menu`;
CREATE TABLE `role_menu` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `role_id` bigint(20) NOT NULL COMMENT '角色id',
  `menu_id` bigint(20) NOT NULL COMMENT '菜单id',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=57 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of role_menu
-- ----------------------------
BEGIN;
INSERT INTO `role_menu` VALUES (1, 1, 1, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (2, 1, 17, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (3, 1, 18, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (4, 1, 19, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (5, 1, 20, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (6, 1, 21, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (7, 1, 22, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (8, 1, 23, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (9, 1, 24, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (10, 1, 25, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (11, 1, 26, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (12, 1, 27, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (13, 1, 28, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (14, 1, 29, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (15, 1, 30, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (16, 1, 31, '2022-01-11 16:12:40', '2022-01-11 16:12:40');
INSERT INTO `role_menu` VALUES (44, 2, 1, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (45, 2, 4, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (46, 2, 9, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (47, 2, 14, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (48, 2, 18, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (49, 2, 23, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (50, 2, 28, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (51, 2, 2, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (52, 2, 7, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (53, 2, 12, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (54, 2, 17, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (55, 2, 22, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
INSERT INTO `role_menu` VALUES (56, 2, 27, '2022-01-11 17:00:18', '2022-01-11 17:00:18');
COMMIT;

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '标签id',
  `user_id` bigint(20) NOT NULL COMMENT '创建者id',
  `tag_name` varchar(20) NOT NULL COMMENT '标签名称',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of tag
-- ----------------------------
BEGIN;
INSERT INTO `tag` VALUES (1, 1, 'SpringBoot', '2022-01-04 16:43:02', '2022-01-04 16:43:02');
INSERT INTO `tag` VALUES (2, 1, 'Android', '2022-01-04 16:43:10', '2022-01-04 16:43:10');
INSERT INTO `tag` VALUES (3, 1, 'Git', '2022-01-04 16:43:19', '2022-01-04 16:43:19');
INSERT INTO `tag` VALUES (4, 1, 'SSL', '2022-01-04 16:44:18', '2022-01-04 16:44:18');
INSERT INTO `tag` VALUES (5, 1, 'Https', '2022-01-04 16:44:22', '2022-01-04 16:44:22');
INSERT INTO `tag` VALUES (6, 1, 'Java', '2022-01-04 17:30:32', '2022-01-04 17:30:32');
INSERT INTO `tag` VALUES (7, 1, 'Mybatis', '2022-01-04 17:30:39', '2022-01-04 17:30:39');
COMMIT;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `username` varchar(255) NOT NULL COMMENT '用户名',
  `password` varchar(255) NOT NULL COMMENT '密码',
  `nickname` varchar(255) DEFAULT NULL COMMENT '昵称',
  `phone` varchar(255) DEFAULT NULL COMMENT '手机号码',
  `email` varchar(255) DEFAULT NULL COMMENT '电子邮箱',
  `avatar` varchar(255) DEFAULT NULL COMMENT '用户头像',
  `locked` tinyint(1) DEFAULT '0' COMMENT '锁定用户',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of user
-- ----------------------------
BEGIN;
INSERT INTO `user` VALUES (1, 'admin', '$2a$10$glZSVIoD0yN6PxDtvQurFueBlPbe8ipaBDcP16l6P7HFB/PXLp5om', NULL, NULL, NULL, NULL, 0, '2022-01-01 00:00:00', '2022-01-01 00:00:00');
INSERT INTO `user` VALUES (2, 'YNetwork', '$2a$10$0IzG3BHA54qfcuIapNx5pOX7VhoJh2e/S0ZlEiFDoWGhB8oPtzxF.', '测试用户', NULL, NULL, NULL, 0, '2022-01-01 00:00:00', '2022-01-11 16:13:55');
COMMIT;

-- ----------------------------
-- Table structure for user_role
-- ----------------------------
DROP TABLE IF EXISTS `user_role`;
CREATE TABLE `user_role` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL COMMENT '用户id',
  `role_id` bigint(20) NOT NULL COMMENT '角色id',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of user_role
-- ----------------------------
BEGIN;
INSERT INTO `user_role` VALUES (1, 2, 2, '2022-01-11 16:13:55', '2022-01-11 16:13:55');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
